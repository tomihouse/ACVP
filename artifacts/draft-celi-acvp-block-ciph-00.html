<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>ACVP Symmetric Block Cipher Algorithm JSON Specification</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.2" rel="Chapter" title="2 Supported Block Cipher Algorithms">
<link href="#rfc.section.3" rel="Chapter" title="3 Test Types and Test Coverage">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Monte Carlo tests for block ciphers">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 AES Monte Carlo Test - ECB mode">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 AES Monte Carlo Test - CBC mode">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 AES Monte Carlo Test - OFB mode">
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 AES Monte Carlo Test - CFB1 mode">
<link href="#rfc.section.3.1.5" rel="Chapter" title="3.1.5 AES Monte Carlo Test - CFB8 mode">
<link href="#rfc.section.3.1.6" rel="Chapter" title="3.1.6 AES Monte Carlo Test - CFB128 mode">
<link href="#rfc.section.3.1.7" rel="Chapter" title="3.1.7 AES Monte Carlo Key Shuffle">
<link href="#rfc.section.3.1.8" rel="Chapter" title="3.1.8 TDES Monte Carlo Test - ECB mode">
<link href="#rfc.section.3.1.9" rel="Chapter" title="3.1.9 TDES Monte Carlo Test - CBC mode">
<link href="#rfc.section.3.1.10" rel="Chapter" title="3.1.10 TDES Monte Carlo Test - CBC-I mode">
<link href="#rfc.section.3.1.11" rel="Chapter" title="3.1.11 TDES Monte Carlo Test - CFB1, CFB8, CFB64 modes">
<link href="#rfc.section.3.1.12" rel="Chapter" title="3.1.12 TDES Monte Carlo Test - CFB1-P, CFB8-P, CFB64-P modes">
<link href="#rfc.section.3.1.13" rel="Chapter" title="3.1.13 TDES Monte Carlo Test - OFB mode">
<link href="#rfc.section.3.1.14" rel="Chapter" title="3.1.14 TDES Monte Carlo Test - OFB-I mode">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Test Coverage">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 AES Requirements Covered">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 AES Requirements Not Covered">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 TDES Requirements Covered">
<link href="#rfc.section.3.2.4" rel="Chapter" title="3.2.4 TDES Requirements Not Covered">
<link href="#rfc.section.3.2.5" rel="Chapter" title="3.2.5 AEAD Requirements Covered">
<link href="#rfc.section.3.2.6" rel="Chapter" title="3.2.6 AEAD Requirements Not Covered">
<link href="#rfc.section.3.2.7" rel="Chapter" title="3.2.7 KeyWrap Requirements Covered">
<link href="#rfc.section.3.2.8" rel="Chapter" title="3.2.8 KeyWrap Requirements Not Covered">
<link href="#rfc.section.4" rel="Chapter" title="4 Capabilities Registration">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Required Prerequisite Algorithms for Block Cipher Validations">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Block Cipher Algorithm Capabilities JSON Values">
<link href="#rfc.section.5" rel="Chapter" title="5 Test Vectors">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Test Groups">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Test Cases">
<link href="#rfc.section.6" rel="Chapter" title="6 Test Vector Responses">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Example Capabilities JSON Object">
<link href="#rfc.appendix.B" rel="Chapter" title="B Example Vector Set Request/Responses JSON Object">
<link href="#rfc.appendix.C" rel="Chapter" title="C Example TDES Test and Results JSON Object">
<link href="#rfc.appendix.D" rel="Chapter" title="D Example TDES MCT Test and Results JSON Object">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.3 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Celi, C., Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-celi-block-ciph-00-1.0" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-02-01" />
  <meta name="dct.abstract" content="This document defines the JSON schema for using symmetric block cipher algorithms with the ACVP specification." />
  <meta name="description" content="This document defines the JSON schema for using symmetric block cipher algorithms with the ACVP specification." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TBD</td>
<td class="right">C. Celi, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">National Institute of Standards and Technology</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">February 1, 2019</td>
</tr>
<tr>
<td class="left">Expires: August 5, 2019</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">ACVP Symmetric Block Cipher Algorithm JSON Specification<br />
  <span class="filename">draft-celi-block-ciph-00-1.0</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines the JSON schema for using symmetric block cipher algorithms with the ACVP specification.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 5, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Supported Block Cipher Algorithms</a>
</li>
<li>3.   <a href="#rfc.section.3">Test Types and Test Coverage</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Monte Carlo tests for block ciphers</a>
</li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">AES Monte Carlo Test - ECB mode</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">AES Monte Carlo Test - CBC mode</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">AES Monte Carlo Test - OFB mode</a>
</li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">AES Monte Carlo Test - CFB1 mode</a>
</li>
<li>3.1.5.   <a href="#rfc.section.3.1.5">AES Monte Carlo Test - CFB8 mode</a>
</li>
<li>3.1.6.   <a href="#rfc.section.3.1.6">AES Monte Carlo Test - CFB128 mode</a>
</li>
<li>3.1.7.   <a href="#rfc.section.3.1.7">AES Monte Carlo Key Shuffle</a>
</li>
<li>3.1.8.   <a href="#rfc.section.3.1.8">TDES Monte Carlo Test - ECB mode</a>
</li>
<li>3.1.9.   <a href="#rfc.section.3.1.9">TDES Monte Carlo Test - CBC mode</a>
</li>
<li>3.1.10.   <a href="#rfc.section.3.1.10">TDES Monte Carlo Test - CBC-I mode</a>
</li>
<li>3.1.11.   <a href="#rfc.section.3.1.11">TDES Monte Carlo Test - CFB1, CFB8, CFB64 modes</a>
</li>
<li>3.1.12.   <a href="#rfc.section.3.1.12">TDES Monte Carlo Test - CFB1-P, CFB8-P, CFB64-P modes</a>
</li>
<li>3.1.13.   <a href="#rfc.section.3.1.13">TDES Monte Carlo Test - OFB mode</a>
</li>
<li>3.1.14.   <a href="#rfc.section.3.1.14">TDES Monte Carlo Test - OFB-I mode</a>
</li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Test Coverage</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">AES Requirements Covered</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">AES Requirements Not Covered</a>
</li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">TDES Requirements Covered</a>
</li>
<li>3.2.4.   <a href="#rfc.section.3.2.4">TDES Requirements Not Covered</a>
</li>
<li>3.2.5.   <a href="#rfc.section.3.2.5">AEAD Requirements Covered</a>
</li>
<li>3.2.6.   <a href="#rfc.section.3.2.6">AEAD Requirements Not Covered</a>
</li>
<li>3.2.7.   <a href="#rfc.section.3.2.7">KeyWrap Requirements Covered</a>
</li>
<li>3.2.8.   <a href="#rfc.section.3.2.8">KeyWrap Requirements Not Covered</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Capabilities Registration</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Required Prerequisite Algorithms for Block Cipher Validations</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Block Cipher Algorithm Capabilities JSON Values</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Test Vectors</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Test Groups</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Test Cases</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Test Vector Responses</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Example Capabilities JSON Object</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Example Vector Set Request/Responses JSON Object</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Example TDES Test and Results JSON Object</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.D">Example TDES MCT Test and Results JSON Object</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">The Automated Cryptographic Validation Protocol (ACVP) defines a mechanism to automatically verify the cryptographic implementation of a software or hardware cryptographic module. The intention of the protocol is to minimize human involvement in the testing of cryptography.  The ACVP specification defines how a cryptographic module communicates with an ACVP server, including cryptographic capabilities negotiation, session management, authentication, vector processing and more. Note that the ACVP specification does not define algorithm-specific JSON constructs for performing the cryptographic validation. However, a series of ACVP sub-specifications defines the constructs for testing individual cryptographic algorithms. Each sub-specification addresses a specific class or subset of cryptographic algorithms. This sub-specification defines the JSON constructs for testing symmetric block cipher cryptographic algorithms using ACVP.  The ACVP server performs a set of tests on the block ciphers in order to assess the correctness and robustness of the implementation. A typical ACVP validation session would require multiple tests to be performed for every supported cryptographic algorithm, such as AES-ECB, AES-CBC, AES-CTR, AES-GCM, TDES-CBC, TDES-CTR, etc.  </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted in <a href="#RFC2119" class="xref">RFC 2119</a> .  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#supported_algs" id="supported_algs">Supported Block Cipher Algorithms</a>
</h1>
<p id="rfc.section.2.p.1">The following block cipher algorithms MAY be advertised by the ACVP compliant cryptographic module:</p>
<p></p>

<ul>
<li>ACVP-AES-ECB</li>
<li>ACVP-AES-CBC</li>
<li>ACVP-AES-OFB</li>
<li>ACVP-AES-CFB1</li>
<li>ACVP-AES-CFB8</li>
<li>ACVP-AES-CFB128</li>
<li>ACVP-AES-CTR</li>
<li>ACVP-AES-GCM</li>
<li>ACVP-AES-GCM-SIV</li>
<li>ACVP-AES-XPN</li>
<li>ACVP-AES-CCM</li>
<li>ACVP-AES-XTS</li>
<li>ACVP-AES-KW</li>
<li>ACVP-AES-KWP</li>
<li>ACVP-TDES-ECB</li>
<li>ACVP-TDES-CBC</li>
<li>ACVP-TDES-CBCI</li>
<li>ACVP-TDES-CFB1</li>
<li>ACVP-TDES-CFB8</li>
<li>ACVP-TDES-CFB64</li>
<li>ACVP-TDES-CFBP1</li>
<li>ACVP-TDES-CFBP8</li>
<li>ACVP-TDES-CFBP64</li>
<li>ACVP-TDES-OFB</li>
<li>ACVP-TDES-OFBI</li>
<li>ACVP-TDES-CTR</li>
<li>ACVP-TDES-KW</li>
</ul>

<p> </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#testtypes" id="testtypes">Test Types and Test Coverage</a>
</h1>
<p id="rfc.section.3.p.1">This section describes the design of the tests used to validate implementations of block cipher algorithms.  There are three types of tests for block ciphers: functional tests, Monte Carlo tests and counter tests. Each has a specific value to be used in the testType field.  The testType field definitions are: </p>

<ul>
<li>"AFT" - Algorithm Functional Test. These tests can be processed by the client using a normal 'encrypt' or 'decrypt' operation.  AFTs cause the implementation under test to exercise normal operations on a single block, multiple blocks, or (where applicable) partial blocks. In some cases random data is used, in others, static, predetermined tests are provided. The functional tests of the block cipher are designed to verify that the logical components of the cipher (GFSbox, KeySbox, block chaining etc.) are operating correctly.  </li>
<li>"MCT" - Monte Carlo Test. These tests exercise the implementation under test under strenuous circumstances. The implementation under test must process the test vectors according to the correct algorithm and mode in this document. MCTs can help detect potential memory leaks over time, and problems in allocation of resources, addressing variables, error handling and generally improper behavior in response to random inputs. Each MCT processes 100 pseudorandom tests. Not every algorithm and mode combination has an MCT.  See <a href="#MC_test" class="xref">Section 3.1</a> for implementation details.  </li>
<li>"CTR" - Counter Mode Test. Counter tests are specifically for counter modes (AES-CTR and TDES-CTR) and require an implementation under test to exercise their counter mechanism. The server will send a long message to the client for encryption or decryption and back-compute the IVs used by the implementation under test. These IVs are then verified for uniqueness and an increasing (or decreasing) nature. The client processes these tests as normal AFTs. The different mode is highlighted here to signify the difference on the server side for processing.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#MC_test" id="MC_test">Monte Carlo tests for block ciphers</a>
</h1>
<p id="rfc.section.3.1.p.1">The MCTs start with an initial condition (plaintext/ciphertext, key, and optional, or maybe multiple IVs) and perform a series of chained computations. For modes that use an IV, the IV is used in the beginning of each pseudorandom process. There are separate rounds of MCT for encryption and decryption. Because some block cipher modes rely on an IV and perform calculations differently from other modes, there are specific definitions of MCT for many of the block cipher modes.  </p>
<p id="rfc.section.3.1.p.2">Note: For all the following, the pseudocode for decryption can be obtained by replacing all PT's with CT's and all CT's with PT's. As well, replace the encrypt operation with the corresponding decrypt operation.  </p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#AES-ECB-MCT" id="AES-ECB-MCT">AES Monte Carlo Test - ECB mode</a>
</h1>
<p id="rfc.section.3.1.1.p.1">The initial condition for the test is the tuple (KEY, PT) set to some values.  </p>
<p id="rfc.section.3.1.1.p.2">The algorithm is shown in <a href="#xml_figureMCTECB" class="xref">Figure 1</a> .  </p>
<div id="rfc.figure.1"></div>
<div id="xml_figureMCTECB"></div>
<p>AES-ECB Monte Carlo Test</p>
<pre>
                            
Key[0] = KEY
PT[0] = PT
For i = 0 to 99
    Output Key[i]
    Output PT[0]
    For j = 0 to 999
        CT[j] = AES_ECB_ENCRYPT(Key[i], PT[j])
        PT[j+1] = CT[j]
    Output CT[j]
    AES_KEY_SHUFFLE(Key, CT)
    PT[0] = CT[j]
                                
                        </pre>
<p class="figure">Figure 1</p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#AES-CBC-MCT" id="AES-CBC-MCT">AES Monte Carlo Test - CBC mode</a>
</h1>
<p id="rfc.section.3.1.2.p.1">The initial condition for the test is the tuple (KEY, IV, PT) set to some values.  </p>
<p id="rfc.section.3.1.2.p.2">The algorithm is shown in <a href="#xml_figureMCTCBC" class="xref">Figure 2</a> .  </p>
<div id="rfc.figure.2"></div>
<div id="xml_figureMCTCBC"></div>
<p>AES-CBC Monte Carlo Test</p>
<pre>
                            
Key[0] = KEY
IV[0] = IV
PT[0] = PT
For i = 0 to 99
    Output Key[i]
    Output IV[i]
    Output PT[0]
    For j = 0 to 999
        If ( j=0 )
            CT[j] = AES_CBC_ENCRYPT(Key[i], IV[i], PT[j])
            PT[j+1] = IV[i]
        Else
            CT[j] = AES_CBC_ENCRYPT(Key[i], PT[j])
            PT[j+1] = CT[j-1]
    Output CT[j]
    AES_KEY_SHUFFLE(Key, CT)
    IV[i+1] = CT[j]
    PT[0] = CT[j-1]
                                
                        </pre>
<p class="figure">Figure 2</p>
<h1 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#AES-OFB-MCT" id="AES-OFB-MCT">AES Monte Carlo Test - OFB mode</a>
</h1>
<p id="rfc.section.3.1.3.p.1">The initial condition for the test is the tuple (KEY, IV, PT) set to some values.  </p>
<p id="rfc.section.3.1.3.p.2">The algorithm is shown in <a href="#xml_figureMCTOFB" class="xref">Figure 3</a> .  </p>
<div id="rfc.figure.3"></div>
<div id="xml_figureMCTOFB"></div>
<p>AES-OFB Monte Carlo Test</p>
<pre>
                            
Key[0] = Key
IV[0] = IV
PT[0] = PT
For i = 0 to 99
    Output Key[i]
    Output IV[i]
    Output PT[0]
    For j = 0 to 999
        If ( j=0 )
            CT[j] = AES_OFB_ENCRYPT(Key[i], IV[i], PT[j])
            PT[j+1] = IV[i]
        Else
            CT[j] = AES_OFB_ENCRYPT(Key[i], PT[j])
            PT[j+1] = CT[j-1]
    Output CT[j]
    AES_KEY_SHUFFLE(Key, CT)
    IV[i+1] = CT[j]
    PT[0] = CT[j-1]
                                
                        </pre>
<p class="figure">Figure 3</p>
<h1 id="rfc.section.3.1.4">
<a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#AES-CFB1-MCT" id="AES-CFB1-MCT">AES Monte Carlo Test - CFB1 mode</a>
</h1>
<p id="rfc.section.3.1.4.p.1">The initial condition for the test is the tuple (KEY, IV, PT) set to some values.  </p>
<p id="rfc.section.3.1.4.p.2">The algorithm is shown in <a href="#xml_figureMCTCFB1" class="xref">Figure 4</a> .  </p>
<div id="rfc.figure.4"></div>
<div id="xml_figureMCTCFB1"></div>
<p>AES-CFB1 Monte Carlo Test</p>
<pre>
                            
Key[0] = Key
IV[0] = IV
PT[0] = PT
For i = 0 to 99
    Output Key[i]
    Output IV[i]
    Output PT[0]
    For j = 0 to 999
        If ( j=0 )
            CT[j] = AES_CFB1_ENCRYPT(Key[i], IV[i], PT[j])
            PT[j+1] = BitJ(IV[i])
        Else
            CT[j] = AES_CFB1_ENCRYPT(Key[i], PT[j])
            If ( j&lt;128 )
                PT[j+1] = BitJ(IV[i])
            Else
                PT[j+1] = CT[j-128]
    Output CT[j]
    If ( keylen = 128 )
        Key[i+1] = Key[i] xor (CT[j-127] || CT[j-126] || ... || CT[j])
    If ( keylen = 192 )
        Key[i+1] = Key[i] xor (CT[j-191] || CT[j-190] || ... || CT[j])
    If ( keylen = 256 )
        Key[i+1] = Key[i] xor (CT[j-255] || CT[j-254] || ... || CT[j])
    IV[i+1] = (CT[j-127] || CT[j-126] || ... || CT[j])
    PT[0] = CT[j-128]
                                
                        </pre>
<p class="figure">Figure 4</p>
<h1 id="rfc.section.3.1.5">
<a href="#rfc.section.3.1.5">3.1.5.</a> <a href="#AES-CFB8-MCT" id="AES-CFB8-MCT">AES Monte Carlo Test - CFB8 mode</a>
</h1>
<p id="rfc.section.3.1.5.p.1">The initial condition for the test is the tuple (KEY, IV, PT) set to some values.  </p>
<p id="rfc.section.3.1.5.p.2">The algorithm is shown in <a href="#xml_figureMCTCFB8" class="xref">Figure 5</a> .  </p>
<div id="rfc.figure.5"></div>
<div id="xml_figureMCTCFB8"></div>
<p>AES-CFB8 Monte Carlo Test</p>
<pre>
                            
Key[0] = Key
IV[0] = IV
PT[0] = PT
For i = 0 to 99
    Output Key[i]
    Output IV[i]
    Output PT[0]
    For j = 0 to 999
        If ( j=0 )
            CT[j] = AES_CFB8_ENCRYPT(Key[i], IV[i], PT[j])
            PT[j+1] = ByteJ(IV[i])
        Else
            CT[j] = AES_CFB8_ENCRYPT(Key[i], PT[j])
            If ( j&lt;16 )
                PT[j+1] = ByteJ(IV[i])
            Else
                PT[j+1] = CT[j-16]
    Output CT[j]
    If ( keylen = 128 )
        Key[i+1] = Key[i] xor (CT[j-15] || CT[j-14] || ... || CT[j])
    If ( keylen = 192 )
        Key[i+1] = Key[i] xor (CT[j-23] || CT[j-22] || ... || CT[j])
    If ( keylen = 256 )
        Key[i+1] = Key[i] xor (CT[j-31] || CT[j-30] || ... || CT[j])
    IV[i+1] = (CT[j-15] || CT[j-14] || ... || CT[j])
    PT[0] = CT[j-16]
                                
                        </pre>
<p class="figure">Figure 5</p>
<h1 id="rfc.section.3.1.6">
<a href="#rfc.section.3.1.6">3.1.6.</a> <a href="#AES-CFB128-MCT" id="AES-CFB128-MCT">AES Monte Carlo Test - CFB128 mode</a>
</h1>
<p id="rfc.section.3.1.6.p.1">The initial condition for the test is the tuple (KEY, IV, PT) set to some values.  </p>
<p id="rfc.section.3.1.6.p.2">The algorithm is shown in <a href="#xml_figureMCTCFB128" class="xref">Figure 6</a> .  </p>
<div id="rfc.figure.6"></div>
<div id="xml_figureMCTCFB128"></div>
<p>AES-CFB128 Monte Carlo Test</p>
<pre>
                            
Key[0] = Key
IV[0] = IV
PT[0] = PT
For i = 0 to 99
    Output Key[i]
    Output IV[i]
    Output PT[0]
    For j = 0 to 999
        If ( j=0 )
            CT[j] = AES_CFB128_ENCRYPT(Key[i], IV[i], PT[j])
            PT[j+1] = IV[i]
        Else
            CT[j] = AES_CFB128_ENCRYPT(Key[i], PT[j])
            PT[j+1] = CT[j-1]
    Output CT[j]
    AES_KEY_SHUFFLE(Key, CT)
    IV[i+1] = CT[j]
    PT[0] = CT[j-1]
                                
                        </pre>
<p class="figure">Figure 6</p>
<h1 id="rfc.section.3.1.7">
<a href="#rfc.section.3.1.7">3.1.7.</a> <a href="#AES_KEY_SHUFFLE" id="AES_KEY_SHUFFLE">AES Monte Carlo Key Shuffle</a>
</h1>
<p id="rfc.section.3.1.7.p.1">Most AES MCTs use a shared key shuffle routine. The algorithm is shown in <a href="#xml_figureAESKEY" class="xref">Figure 7</a> .  The initial condition for the routine is a tuple (KEY, CT) set to some values. This pseudocode is specifically for encryption. For decryption, swap all instances of CT with PT.  </p>
<div id="rfc.figure.7"></div>
<div id="xml_figureAESKEY"></div>
<p>AES Encrypt Key Shuffle Routine</p>
<pre>
                            
If ( keylen = 128 )
    Key[i+1] = Key[i] xor CT[j]
If ( keylen = 192 )
    Key[i+1] = Key[i] xor (last 64-bits of CT[j-1] || CT[j])
If ( keylen = 256 )
    Key[i+1] = Key[i] xor (CT[j-1] || CT[j])
                                
                        </pre>
<p class="figure">Figure 7</p>
<h1 id="rfc.section.3.1.8">
<a href="#rfc.section.3.1.8">3.1.8.</a> <a href="#TDES-ECB-MCT" id="TDES-ECB-MCT">TDES Monte Carlo Test - ECB mode</a>
</h1>
<p id="rfc.section.3.1.8.p.1">The initial condition for the test is the tuple (KEY1, KEY2, KEY3, PT) set to some values.  </p>
<p id="rfc.section.3.1.8.p.2">The algorithm is shown in <a href="#xml_figureMCT_TDES_ECB" class="xref">Figure 8</a> .  </p>
<div id="rfc.figure.8"></div>
<div id="xml_figureMCT_TDES_ECB"></div>
<p>TDES-ECB Monte Carlo Test</p>
<pre>
                            
Key1[0] = KEY1
Key2[0] = KEY2
Key3[0] = KEY3
PT[0] = PT
For i = 0 to 399
    Output Key1[i]
    Output Key2[i]
    Output Key3[i]
    Output PT[0]
    For j = 0 to 9999
        CT[j] = TDES_ECB_ENCRYPT(Key1[i], Key2[i], Key3[i], PT[j])
        PT[j+1] = CT[i]
    Output CT[j]
    Key1[i+1] = Key1[i] xor CT[j]
    Key2[i+1] = Key2[i] xor CT[j-1]
    If ( keyingOption = 1 )
        Key3[i+1] = Key3[i] xor CT[j-2]
    Else
        Key3[i+1] = Key1[i+1]
    PT[0] = CT[j-1]
                                
                        </pre>
<p class="figure">Figure 8</p>
<h1 id="rfc.section.3.1.9">
<a href="#rfc.section.3.1.9">3.1.9.</a> <a href="#TDES-CBC-MCT" id="TDES-CBC-MCT">TDES Monte Carlo Test - CBC mode</a>
</h1>
<p id="rfc.section.3.1.9.p.1">The initial condition for the test is the tuple (KEY1, KEY2, KEY3, IV, PT) set to some values.  </p>
<p id="rfc.section.3.1.9.p.2">The algorithm is shown in <a href="#xml_figureMCT_TDES_CBC" class="xref">Figure 9</a> .  </p>
<div id="rfc.figure.9"></div>
<div id="xml_figureMCT_TDES_CBC"></div>
<p>TDES-CBC Monte Carlo Test</p>
<pre>
                            
Key1[0] = KEY1
Key2[0] = KEY2
Key3[0] = KEY3
IV[0] = IV
PT[0] = PT
For i = 0 to 399
    Output Key1[i]
    Output Key2[i]
    Output Key3[i]
    Output IV[0]
    Output PT[0]
    For j = 0 to 9999
        CT[j] = TDES_CBC_ENCRYPT(Key1[i], Key2[i], Key3[i], 
                                 PT[j], IV[j])
        If ( j = 0 )
            PT[j+1] = IV[0]
        Else
            PT[j+1] = CT[j-1]
        IV[j+1] = CT[j]
    Output CT[j]
    Key1[i+1] = Key1[i] xor CT[j]
    Key2[i+1] = Key2[i] xor CT[j-1]
    If ( keyingOption = 1 )
        Key3[i+1] = Key3[i] xor CT[j-2]
    Else
        Key3[i+1] = Key1[i+1]
    PT[0] = CT[j-1]
    IV[0] = CT[j]
                                
                        </pre>
<p class="figure">Figure 9</p>
<h1 id="rfc.section.3.1.10">
<a href="#rfc.section.3.1.10">3.1.10.</a> <a href="#TDES-CBC-I-MCT" id="TDES-CBC-I-MCT">TDES Monte Carlo Test - CBC-I mode</a>
</h1>
<p id="rfc.section.3.1.10.p.1">The initial condition for the test is the tuple (KEY1, KEY2, KEY3, IV1, IV2, IV3, PT1, PT2, PT3) set to some values.  </p>
<p id="rfc.section.3.1.10.p.2">The algorithm is shown in <a href="#xml_figureMCT_TDES_CBC-I" class="xref">Figure 10</a> .  </p>
<div id="rfc.figure.10"></div>
<div id="xml_figureMCT_TDES_CBC-I"></div>
<p>TDES-CBC-I Monte Carlo Test</p>
<pre>
                            
Key1[0] = KEY1
Key2[0] = KEY2
Key3[0] = KEY3
IV1[0] = IV1
IV2[0] = IV2
IV3[0] = IV3
PT1[0] = PT1
PT2[0] = PT2
PT3[0] = PT3
For i = 0 to 399
    Output Key1[i], Key2[i], Key3[i]
    Output IV1[0], IV2[0], IV3[0]
    Output PT1[0], PT2[0], PT3[0]
    For j = 0 to 9999
        CT[j] = TDES_CBC_I_ENCRYPT(Key1[i], Key2[i], 
                                   Key3[i], PT1[j], PT2[j],
                                   PT3[j], IV1[j], IV2[j], IV3[j])
        If ( j = 0 )
            PT1[j+1] = IV1[0]
            PT2[j+1] = IV2[0]
            PT3[j+1] = IV3[0]
        Else
            PT1[j+1] = CT1[j-1]
            PT2[j+1] = CT2[j-1]
            PT3[j+1] = CT3[j-1]
        IV1[j+1] = CT1[j]
        IV2[j+1] = CT2[j]
        IV3[j+1] = CT3[j]
    Output CT1[j], CT2[j], CT3[j]
    Key1[i+1] = Key1[i] xor CT[j]
    Key2[i+1] = Key2[i] xor CT[j-1]
    If ( keyingOption = 1 )
        Key3[i+1] = Key3[i] xor CT[j-2]
    Else
        Key3[i+1] = Key1[i+1]
    PT1[0] = CT1[j-1]
    PT2[0] = CT2[j-1]
    PT3[0] = CT3[j-1]
    IV1[0] = CT1[j]
    IV2[0] = CT2[j]
    IV3[0] = CT3[j]
                                
                        </pre>
<p class="figure">Figure 10</p>
<h1 id="rfc.section.3.1.11">
<a href="#rfc.section.3.1.11">3.1.11.</a> <a href="#TDES-CFB-MCT" id="TDES-CFB-MCT">TDES Monte Carlo Test - CFB1, CFB8, CFB64 modes</a>
</h1>
<p id="rfc.section.3.1.11.p.1">The initial condition for the test is the tuple (KEY1, KEY2, KEY3, IV, PT) set to some values. Note: PT and CT are k-bit where k is the feedback size, for example CFB1 has a feedback size of 1-bit.  </p>
<p id="rfc.section.3.1.11.p.2">The algorithm is shown in <a href="#xml_figureMCT_TDES_CFB" class="xref">Figure 11</a> .  </p>
<div id="rfc.figure.11"></div>
<div id="xml_figureMCT_TDES_CFB"></div>
<p>TDES-CFB Monte Carlo Test</p>
<pre>
                            
Key1[0] = KEY1
Key2[0] = KEY2
Key3[0] = KEY3
IV[0] = IV
PT[0] = PT
For i = 0 to 399
    Output Key1[i]
    Output Key2[i]
    Output Key3[i]
    Output IV[0]
    Output PT[0]
    For j = 0 to 9999
        CT[j] = TDES_CFB_ENCRYPT(Key1[i], Key2[i], Key3[i], 
                                 PT[j], IV[j])
        PT[j+1] = LeftMost_K_Bits(IV[j])
        IV[j+1] = RightMost_64-K_Bits(IV[j]) || CT[j]
    Output CT[j]
    C = LeftMost_192_Bits(CT[j] || CT[j-1] || ... || CT[0])
    Key1[i+1] = Key1[i] xor bits 129-192 of C
    Key2[i+1] = Key2[i] xor bits 65-128 of C
    If ( keyingOption = 1 )
        Key3[i+1] = Key3[i] xor bits 1-64 of C
    Else
        Key3[i+1] = Key1[i+1]
    PT[0] = LeftMost_K_Bits(IV[j])
    IV[0] = RightMost_64-K_Bits(IV[j]) || CT[j]
                                
                        </pre>
<p class="figure">Figure 11</p>
<h1 id="rfc.section.3.1.12">
<a href="#rfc.section.3.1.12">3.1.12.</a> <a href="#TDES-CFB-P-MCT" id="TDES-CFB-P-MCT">TDES Monte Carlo Test - CFB1-P, CFB8-P, CFB64-P modes</a>
</h1>
<p id="rfc.section.3.1.12.p.1">The initial condition for the test is the tuple (KEY1, KEY2, KEY3, IV1, IV2, IV3, PT) set to some values. Note: PT and CT are k-bit where k is the feedback size, for example CFB8-P has a feedback size of 8-bits.  </p>
<p id="rfc.section.3.1.12.p.2">The algorithm is shown in <a href="#xml_figureMCT_TDES_CFB-P" class="xref">Figure 12</a> .  </p>
<div id="rfc.figure.12"></div>
<div id="xml_figureMCT_TDES_CFB-P"></div>
<p>TDES-CFB-P Monte Carlo Test</p>
<pre>
                            
Key1[0] = KEY1
Key2[0] = KEY2
Key3[0] = KEY3
IV1[0] = IV1
IV2[0] = IV2
IV3[0] = IV3
PT[0] = PT
For i = 0 to 399
    Output Key1[i], Key2[i], Key3[i]
    Output IV1[0]
    Output PT[0]
    For j = 0 to 9999
        CT[j] = TDES_CFB_P_ENCRYPT(Key1[i], Key2[i], Key3[i], 
                                   PT[j], IV1[j], IV2[j], IV3[j])
        PT[j+1] = LeftMost_K_Bits(IV1[j])
    Output CT[j]
    C = LeftMost_192_Bits(CT[j] || CT[j-1] || ... || CT[0])
    Key1[i+1] = Key1[i] xor bits 129-192 of C
    Key2[i+1] = Key2[i] xor bits 65-128 of C
    If ( keyingOption = 1 )
        Key3[i+1] = Key3[i] xor bits 1-64 of C
    Else
        Key3[i+1] = Key1[i+1]
    PT[0] = LeftMost_K_Bits(IV1[j])
    IV1[0] = RightMost_64-K_Bits(IV[j]) || CT[j]
    IV2[0] = IV1[0] + "5555555555555555" mod 2^64
    IV3[0] = IV1[0] + "AAAAAAAAAAAAAAAA" mod 2^64
                                
                        </pre>
<p class="figure">Figure 12</p>
<h1 id="rfc.section.3.1.13">
<a href="#rfc.section.3.1.13">3.1.13.</a> <a href="#TDES-OFB-MCT" id="TDES-OFB-MCT">TDES Monte Carlo Test - OFB mode</a>
</h1>
<p id="rfc.section.3.1.13.p.1">The initial condition for the test is the tuple (KEY1, KEY2, KEY3, IV, PT) set to some values.  </p>
<p id="rfc.section.3.1.13.p.2">The algorithm is shown in <a href="#xml_figureMCT_TDES_OFB" class="xref">Figure 13</a> .  </p>
<div id="rfc.figure.13"></div>
<div id="xml_figureMCT_TDES_OFB"></div>
<p>TDES-OFB Monte Carlo Test</p>
<pre>
                            
Key1[0] = KEY1
Key2[0] = KEY2
Key3[0] = KEY3
IV[0] = IV
PT[0] = PT
For i = 0 to 399
    Output Key1[i]
    Output Key2[i]
    Output Key3[i]
    Output IV[0]
    Output PT[0]
    For j = 0 to 9999
        CT[j] = TDES_OFB_ENCRYPT(Key1[i], Key2[i], Key3[i], 
                                 PT[j], IV[j])
        PT[j+1] = IV[j]
    Output CT[j]
    Key1[i+1] = Key1[i] xor CT[j]
    Key2[i+1] = Key2[i] xor CT[j-1]
    If ( keyingOption = 1 )
        Key3[i+1] = Key3[i] xor CT[j-2]
    Else
        Key3[i+1] = Key1[i+1]
    PT[0] = PT[0] xor IV[j]
    IV[0] = CT[j]
                                
                        </pre>
<p class="figure">Figure 13</p>
<h1 id="rfc.section.3.1.14">
<a href="#rfc.section.3.1.14">3.1.14.</a> <a href="#TDES-OFB-I-MCT" id="TDES-OFB-I-MCT">TDES Monte Carlo Test - OFB-I mode</a>
</h1>
<p id="rfc.section.3.1.14.p.1">The initial condition for the test is the tuple (KEY1, KEY2, KEY3, IV1, IV2, IV3, PT) set to some values.  </p>
<p id="rfc.section.3.1.14.p.2">The algorithm is shown in <a href="#xml_figureMCT_TDES_OFB-I" class="xref">Figure 14</a> .  </p>
<div id="rfc.figure.14"></div>
<div id="xml_figureMCT_TDES_OFB-I"></div>
<p>TDES-OFB-I Monte Carlo Test</p>
<pre>
                            
Key1[0] = KEY1
Key2[0] = KEY2
Key3[0] = KEY3
IV1[0] = IV1
IV2[0] = IV2
IV3[0] = IV3
PT[0] = PT
For i = 0 to 399
    Output Key1[i], Key2[i], Key3[i]
    Output IV1[0], IV2[0], IV3[0]
    Output PT[0]
    For j = 0 to 9999
        CT[j] = TDES_OFB-I_ENCRYPT(Key1[i], Key2[i], Key3[i], 
                                   PT[j], IV[j])
        PT[j+1] = IV[j]
    Output CT[j]
    Key1[i+1] = Key1[i] xor CT[j]
    Key2[i+1] = Key2[i] xor CT[j-1]
    If ( keyingOption = 1 )
        Key3[i+1] = Key3[i] xor CT[j-2]
    Else
        Key3[i+1] = Key1[i+1]
    PT[0] = PT[0] xor IV1[j]
    IV1[0] = CT[j]
    IV2[0] = IV1[0] + "5555555555555555" mod 2^64
    IV3[0] = IV1[0] + "AAAAAAAAAAAAAAAA" mod 2^64
                                
                        </pre>
<p class="figure">Figure 14</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#test_coverage" id="test_coverage">Test Coverage</a>
</h1>
<p id="rfc.section.3.2.p.1">The tests described in this document have the intention of ensuring an implementation is conformant to <a href="#FIPS-197" class="xref">[FIPS-197]</a> and <a href="#SP800-38A" class="xref">[SP800-38A]</a> .  </p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#aes-coverage" id="aes-coverage">AES Requirements Covered</a>
</h1>
<p id="rfc.section.3.2.1.p.1">In <a href="#SP800-38A" class="xref">[SP800-38A]</a>, both Section 5 and Section 6 which describe general modes of operation for block ciphers are tested. In <a href="#FIPS-197" class="xref">[FIPS-197]</a>, Section 4 outlines the AES engine and necessary functions to perform simple encrypt an decrypt operations. All AES tests perform such operations and thus rely heavily on this section. Section 5 specifically outlines the algorithm for AES and thus all AES tests rely heavily on this section as well.  In <a href="#AES-XTS" class="xref">[AES-XTS]</a>, the IEEE outlines the encrypt and decrypt operations for AES-XTS.  </p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#aes-not-coverage" id="aes-not-coverage">AES Requirements Not Covered</a>
</h1>
<p id="rfc.section.3.2.2.p.1">Some requirements in the outlined specifications are not easily tested. Often they are not ideal for black-box testing such as the ACVP.  In <a href="#SP800-38A" class="xref">[SP800-38A]</a>, Appendix A outlines padding for when the data being encrypted does not evenly fill the blocks. In these tests, all data, unless otherwise specified, is assumed to be a multiple of the block length. All exceptions to those cases are when stream ciphers specifically are being tested. In Section 5.3, IV generation which is required for all modes of AES and TDES outside of ECB, is not tested.  Appendix D outlines how errors are to be handled. As some symmetric ciphers aren't authenticated, ACVP does not include tests that change random bits in payload, IV, key or results, as these results can be successfully encrypted/decrypted, but errors aren't necessarily detectable.  In <a href="#FIPS-197" class="xref">[FIPS-197]</a>, Section 5.3 defines the inverse cipher for AES. This is not tested in the CBC, CFB (all), OFB or CTR modes.  In <a href="#SP800-38E" class="xref">[SP800-38E]</a>, the AES-XTS algorithm is restricted to 2^20 AES blocks (128-bits each) per key. Due to the size of the data, ACVP does not test the proper usage of a key over such large amounts of data.  </p>
<h1 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> <a href="#tdes-coverage" id="tdes-coverage">TDES Requirements Covered</a>
</h1>
<p id="rfc.section.3.2.3.p.1">In <a href="#SP800-67r2" class="xref">[SP800-67r2]</a>, Section 3 outlines the use for TDES with keying option 1 (three distinct keys) and decryption only for keying option 2 (K1 == K3 != K2). Depending on the cipher mode, both the forward and inverse cipher are tested. The known answer tests address these requirements.  </p>
<h1 id="rfc.section.3.2.4">
<a href="#rfc.section.3.2.4">3.2.4.</a> <a href="#tdes-not-coverage" id="tdes-not-coverage">TDES Requirements Not Covered</a>
</h1>
<p id="rfc.section.3.2.4.p.1">In <a href="#SP800-67r2" class="xref">[SP800-67r2]</a>, Section 3.3 outlines requirements for keys for proper usage of TDES. These requirements are not tested by ACVP.  All keys used in the tests are randomly or staticly generated by the server. There are no checks for key equality or potentially weak keys. Section 3.3.2 outlines specific keys which are to be avoided. ACVP does not expect a client to be able to detect these keys.  </p>
<h1 id="rfc.section.3.2.5">
<a href="#rfc.section.3.2.5">3.2.5.</a> <a href="#aead-coverage" id="aead-coverage">AEAD Requirements Covered</a>
</h1>
<p id="rfc.section.3.2.5.p.1">In <a href="#SP800-38D" class="xref">[SP800-38D]</a>, Section 7 outlines the encrypt and decrypt operations for AES-GCM. This and all prerequisites to these operations (such as GHASH) are tested as AES-GCM encrypt and decrypt operations.  In <a href="#SP800-38C" class="xref">[SP800-38C]</a>, Section 6 outlines the encrypt and decrypt operations for AES-CCM. This and all prerequisites to these operations (such as CBC-MAC) are tested as AES-CCM encrypt and decrypt operations.  In <a href="#AES-GCM-SIV" class="xref">[AES-GCM-SIV]</a>, the draft outlines the encrypt and decrypt operations for AES-GCM-SIV.  </p>
<h1 id="rfc.section.3.2.6">
<a href="#rfc.section.3.2.6">3.2.6.</a> <a href="#aead-not-coverage" id="aead-not-coverage">AEAD Requirements Not Covered</a>
</h1>
<p id="rfc.section.3.2.6.p.1">In <a href="#SP800-38D" class="xref">[SP800-38D]</a>, Section 8 outlines uniqueness requirements on IVs and keys for AES-GCM. This is considered out of bounds for the algorithm testing done by the ACVP and will not be tested.  </p>
<h1 id="rfc.section.3.2.7">
<a href="#rfc.section.3.2.7">3.2.7.</a> <a href="#kw-coverage" id="kw-coverage">KeyWrap Requirements Covered</a>
</h1>
<p id="rfc.section.3.2.7.p.1">In <a href="#SP800-38F" class="xref">[SP800-38F]</a> Section 5.2 defines the authenticated encryption and authenticated decryption operations for all three key-wrap algorithms.  As well, the padding for key-wrap with padding is defined. Algorithm Functional Tests provide assurance of these requirements for encrypt operations. For decrypt operations, there is a possibility to reject the ciphertext due to improper wrapping. This is also assured by the Algorithm Functional Tests.  Sections 6 and 7 outline the specific ciphers in both encrypt and decrypt directions. All facsets of these processes are tested with random data via the Algorithm Functional Tests.  </p>
<h1 id="rfc.section.3.2.8">
<a href="#rfc.section.3.2.8">3.2.8.</a> <a href="#kw-not-coverage" id="kw-not-coverage">KeyWrap Requirements Not Covered</a>
</h1>
<p id="rfc.section.3.2.8.p.1">In <a href="#SP800-38F" class="xref">[SP800-38F]</a> Section 5.3 defines the length requirements allowed by an optimal implementation. The upper bounds are unreasonably large to test in a web-based model and thus an artificial maximum is selected for the payloadLen property (corresponding to both plaintext and ciphertext). The Algorithm Functional Tests SHOULD utilize both the minimum and maximum values provided in the client's registration optimally with other values.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#caps_reg" id="caps_reg">Capabilities Registration</a>
</h1>
<p id="rfc.section.4.p.1">This section describes the constructs for advertising support of block cipher algorithms to the ACVP server. ACVP REQURIES cryptographic modules to register their capabilities in a registration.  This allows the cryptographic module to advertise support for specific algorithms, notifying the ACVP server which algorithms need test vectors generated for the validation process.  </p>
<p id="rfc.section.4.p.2">The block cipher algorithm capabilities MUST be advertised as JSON objects within the 'algorithms' value of the ACVP registration message. The 'algorithms' value MUST be an array, where each array element is an individual JSON object defined in this section. The 'algorithms' value MUST be part of the 'capability_exchange' element of the ACVP JSON registration message.  See the ACVP Protocol Specification Section XXX for details on the registration message.  Each block cipher algorithm capability advertised SHALL be a self-contained JSON object.  </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#prereq_algs" id="prereq_algs">Required Prerequisite Algorithms for Block Cipher Validations</a>
</h1>
<p id="rfc.section.4.1.p.1">Some block cipher algorithm implementations rely on other cryptographic primitives.  For example, AES-CCM uses an underlying AES-ECB algorithm. Each of these underlying algorithm primitives MUST be validated, either separately or as part of the same submission. ACVP provides a mechanism for specifying the required prerequisites: </p>
<div id="rfc.table.1"></div>
<div id="prereqs_table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Required Prerequisite Algorithms JSON Values</caption>
<thead><tr>
<th class="left">JSON Value</th>
<th class="left">Description</th>
<th class="left">JSON type</th>
<th class="left">Example Values</th>
</tr></thead>
<tbody>
<tr>
<td class="left">algorithm</td>
<td class="left">a prerequisite algorithm</td>
<td class="left">string</td>
<td class="left">AES, DRBG, TDES</td>
</tr>
<tr>
<td class="left">valValue</td>
<td class="left">algorithm validation number</td>
<td class="left">string</td>
<td class="left">actual number or "same" to refer to the same submission</td>
</tr>
<tr>
<td class="left">prereqAlgVal</td>
<td class="left">prerequisite algorithm validation</td>
<td class="left">object</td>
<td class="left">exactly one algorithm property and one valValue property</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#cap_ex" id="cap_ex">Block Cipher Algorithm Capabilities JSON Values</a>
</h1>
<p id="rfc.section.4.2.p.1">Each algorithm capability advertised is a self-contained JSON object and SHALL use the following values when appropriate:</p>
<div id="rfc.table.2"></div>
<div id="caps_table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Block Cipher Algorithm Capabilities JSON Values</caption>
<thead><tr>
<th class="left">JSON Value</th>
<th class="left">Description</th>
<th class="left">JSON type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">algorithm</td>
<td class="left">The block cipher algorithm and mode to be validated.</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">revision</td>
<td class="left">The version of the testing methodology the IUT is requesting to validate against.</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">prereqVals</td>
<td class="left">Prerequisite algorithm validations</td>
<td class="left">array of prereqAlgVal objects described in <a href="#prereqs_table" class="xref">Table 1</a> </td>
</tr>
<tr>
<td class="left">direction</td>
<td class="left">The IUT processing direction</td>
<td class="left">array of strings</td>
</tr>
<tr>
<td class="left">keyLen</td>
<td class="left">The supported key lengths in bits</td>
<td class="left">array of integers</td>
</tr>
<tr>
<td class="left">payloadLen</td>
<td class="left">The supported plain and cipher text lengths in bits. This varies depending on the algorithm type, for additional details see <a href="#property_grid_auth" class="xref">Table 4</a> and <a href="#property_grid_misc" class="xref">Table 6</a> </td>
<td class="left">domain</td>
</tr>
<tr>
<td class="left">ivLen</td>
<td class="left">The supported IV/Nonce lengths in bits, see <a href="#property_grid_auth" class="xref">Table 4</a> </td>
<td class="left">domain</td>
</tr>
<tr>
<td class="left">ivGen</td>
<td class="left">IV generation method for AES-GCM/AES-XPN algorithms</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">ivGenMode</td>
<td class="left">IV generation mode for AES-GCM/AES-XPN algorithms</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">saltGen</td>
<td class="left">Salt generation method for AES-XPN mode only</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">aadLen</td>
<td class="left">The supported AAD lengths in bits for AEAD algorithms</td>
<td class="left">domain</td>
</tr>
<tr>
<td class="left">tagLen</td>
<td class="left">The supported Tag lengths in bits for AEAD algorithms, see <a href="#property_grid_auth" class="xref">Table 4</a> </td>
<td class="left">domain</td>
</tr>
<tr>
<td class="left">kwCipher</td>
<td class="left">The cipher as defined in SP800-38F for key wrap mode</td>
<td class="left">array of strings</td>
</tr>
<tr>
<td class="left">tweakMode</td>
<td class="left">The format of tweak value input for AES-XTS. Hex refers to the tweakValue being a literal hex string. Number refers to the tweakValue being an integer number represented as a hex string.</td>
<td class="left">array of strings</td>
</tr>
<tr>
<td class="left">keyingOption</td>
<td class="left">The Keying Option used in TDES.  Keying option 1 (1) is 3 distinct keys (K1, K2, K3).  Keying Option 2 (2) is 2 distinct keys only suitable for decrypt (K1, K2, K1).  </td>
<td class="left">array of integers</td>
</tr>
<tr>
<td class="left">overflowCounter</td>
<td class="left">Indicates if the implementation can handle a counter exceeding the maximum value</td>
<td class="left">boolean</td>
</tr>
<tr>
<td class="left">incrementalCounter</td>
<td class="left">Indicates if the implementation increments the counter (versus decrementing the counter)</td>
<td class="left">boolean</td>
</tr>
</tbody>
</table>
<p id="rfc.section.4.2.p.2">Note: Some optional values are required depending on the algorithm. For example, AES-GCM requires ivLen, ivGen, ivGenMode, aadLen and tagLen. Failure to provide these values will result in the ACVP server returning an error to the ACVP client during registration.  </p>
<p id="rfc.section.4.2.p.3">The following grid outlines which properties are REQUIRED, as well as all the possible values a server MAY support for each standard block cipher algorithm:</p>
<div id="rfc.table.3"></div>
<div id="property_grid"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Standard Block Cipher Algorithm Capabilities Applicability Grid</caption>
<thead><tr>
<th class="left">algorithm</th>
<th class="left">revision</th>
<th class="left">direction</th>
<th class="left">keyLen</th>
<th class="left">keyingOption</th>
</tr></thead>
<tbody>
<tr>
<td class="left">AES-ECB</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-CBC</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-OFB</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-CFB1</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-CFB8</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-CFB128</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">TDES-ECB</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-CBC</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-CBCI</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-CFB1</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-CFB8</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-CFB64</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-CFBP1</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-CFBP8</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-CFBP64</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-OFB</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
<tr>
<td class="left">TDES-OFBI</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
</tbody>
</table>
<p id="rfc.section.4.2.p.4">Note: keyingOption 2 SHALL only available for decrypt operations.</p>
<p id="rfc.section.4.2.p.5">The following grid outlines which properties are REQUIRED, as well as the possible values a server MAY support for each authenticated block cipher algorithm:</p>
<div id="rfc.table.4"></div>
<div id="property_grid_auth"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Authenticated Block Cipher Algorithm Capabilities Applicability Grid</caption>
<thead><tr>
<th class="left">algorithm</th>
<th class="left">revision</th>
<th class="left">direction</th>
<th class="left">keyLen</th>
<th class="left">kwCipher</th>
<th class="left">keyingOption</th>
</tr></thead>
<tbody>
<tr>
<td class="left">AES-KW</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left">["cipher", "inverse"]</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-KWP</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left">["cipher", "inverse"]</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">TDES-KW</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">["cipher", "inverse"]</td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
</tr>
</tbody>
</table>
<p id="rfc.section.4.2.p.6">The following grid outlines which properties are REQUIRED, as well as the possible values a server MAY support for each key-wrap block cipher algorithm:</p>
<div id="rfc.table.5"></div>
<div id="property_grid_kw"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Key-Wrap Block Cipher Algorithm Capabilities Applicability Grid</caption>
<thead><tr>
<th class="left">algorithm</th>
<th class="left">revision</th>
<th class="left">direction</th>
<th class="left">keyLen</th>
<th class="left">payloadLen</th>
<th class="left">ivLen</th>
<th class="left">ivGen</th>
<th class="left">ivGenMode</th>
<th class="left">saltGen</th>
<th class="left">aadLen</th>
<th class="left">tagLen</th>
</tr></thead>
<tbody>
<tr>
<td class="left">AES-GCM</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left">{"Min": 0, "Max": 65536, "Inc": any}</td>
<td class="left">{"Min": 8, "Max": 1024, "Inc": any}</td>
<td class="left">["internal", "external"]</td>
<td class="left">["8.2.1", "8.2.2"]</td>
<td class="left"></td>
<td class="left">{"Min": 0, "Max": 65536, "Inc": any}</td>
<td class="left">{[32, 64, 96, 104, 112, 120, 128]}</td>
</tr>
<tr>
<td class="left">AES-GCM-SIV</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 256]</td>
<td class="left">{"Min": 0, "Max": 65536, "Inc": 8}</td>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
<td class="left">{"Min": 0, "Max": 65536, "Inc": 8}</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-XPN</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left">{"Min": 0, "Max": 65536, "Inc": any}</td>
<td class="left"></td>
<td class="left">["internal", "external"]</td>
<td class="left">["8.2.1", "8.2.2"]</td>
<td class="left">["internal", "external"]</td>
<td class="left">{"Min": 1, "Max": 65536, "Inc": any}</td>
<td class="left">{[32, 64, 96, 104, 112, 120, 128]}</td>
</tr>
<tr>
<td class="left">AES-CCM</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left">{"Min": 0, "Max": 256, "Inc": 8}</td>
<td class="left">{"Min": 56, "Max": 104, "Inc": 8}</td>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
<td class="left">{"Min": 0, "Max": 524288, "Inc": any}</td>
<td class="left">{"Min": 32, "Max": 128, "Inc": 16}</td>
</tr>
</tbody>
</table>
<p id="rfc.section.4.2.p.7">The following grid outlines which properties are REQUIRED, as well as the possible values a server MAY support for each miscellaneous block cipher algorithm:</p>
<div id="rfc.table.6"></div>
<div id="property_grid_misc"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Miscellaneous Block Cipher Algorithm Capabilities Applicability Grid</caption>
<thead><tr>
<th class="left">algorithm</th>
<th class="left">revision</th>
<th class="left">direction</th>
<th class="left">keyLen</th>
<th class="left">payloadLen</th>
<th class="left">tweakMode</th>
<th class="left">keyingOption</th>
<th class="left">overflowCounter</th>
<th class="left">incrementalCounter</th>
</tr></thead>
<tbody>
<tr>
<td class="left">AES-CTR</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 192, 256]</td>
<td class="left">{"Min": 1, "Max": 128, "Inc": any}</td>
<td class="left"></td>
<td class="left"></td>
<td class="left">true, false</td>
<td class="left">true, false</td>
</tr>
<tr>
<td class="left">AES-XTS</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left">[128, 256]</td>
<td class="left">{"Min": 128, "Max": 65536, "Inc": 128}</td>
<td class="left">["hex", "number"]</td>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
</tr>
<tr>
<td class="left">TDES-CTR</td>
<td class="left">"1.0.0"</td>
<td class="left">["encrypt", "decrypt"]</td>
<td class="left"></td>
<td class="left">{"Min": 1, "Max": 64, "Inc": any}</td>
<td class="left"></td>
<td class="left">[1, 2] Note: 2 is only available for decrypt operations</td>
<td class="left">true, false</td>
<td class="left">true, false</td>
</tr>
</tbody>
</table>
<p id="rfc.section.4.2.p.8">Note: keyingOption 2 SHALL only available for decrypt operations.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#test_vectors" id="test_vectors">Test Vectors</a>
</h1>
<p id="rfc.section.5.p.1">After receiving a valid registration of a cryptographic module, the ACVP server SHALL provide test vectors in the form of a prompt to the ACVP client, which then SHALL be processed and returned to the ACVP server for validation.  A typical ACVP validation session would require the client to download and process multiple test vector sets.  Each test vector set SHALL represent an individual cryptographic algorithm, such as AES-ECB, AES-CBC, TDES-CTR, etc.  This section describes the JSON schema for a test vector set used with block cipher algorithms.  </p>
<p id="rfc.section.5.p.2">The test vector set JSON schema is a multi-level hierarchy that contains meta-data for the entire vector set. The test vector set SHALL be comprised of test groups which SHALL subsequently contain individual test cases to be processed by the ACVP client. The following table describes the REQUIRED JSON elements at the top level of the hierarchy: </p>
<div id="rfc.table.7"></div>
<div id="vs_top_table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Test Vector Set JSON Object</caption>
<thead><tr>
<th class="left">JSON Value</th>
<th class="left">Description</th>
<th class="left">JSON type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">acvVersion</td>
<td class="left">Protocol version identifier</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">vsId</td>
<td class="left">Unique numeric identifier for the vector set</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">algorithm</td>
<td class="left">The block cipher algorithm and mode used for the test vectors. See <a href="#supported_algs" class="xref">Section 2</a> for possible values.  </td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">revision</td>
<td class="left">The version of the testing methodologies used in the vector set.</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">testGroups</td>
<td class="left">Array of test group JSON objects, which are defined in <a href="#tgjs" class="xref">Section 5.1</a> </td>
<td class="left">array of testGroup objects</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#tgjs" id="tgjs">Test Groups</a>
</h1>
<p id="rfc.section.5.1.p.1">Test vector sets MUST contain one or many test groups, each sharing similar properties.  For instance, all test vectors that use the same key size would be grouped together.  The testGroups element at the top level of the test vector JSON object SHALL be the array of test groups.  The Test Group JSON object MUST contain meta-data that applies to all test cases within the group.  The following table describes the JSON elements that MAY appear from the server in the Test Group JSON object: </p>
<div id="rfc.table.8"></div>
<div id="vs_tg_table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Test Group JSON Object</caption>
<thead><tr>
<th class="left">JSON Value</th>
<th class="left">Description</th>
<th class="left">JSON type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">tgId</td>
<td class="left">Numeric identifier for the test group, unique across the entire vector set.</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">direction</td>
<td class="left">The IUT processing direction: encrypt or decrypt</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">ivGen</td>
<td class="left">IV generation method</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">ivGenMode</td>
<td class="left">IV generation method</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">saltGen</td>
<td class="left">Salt generation method</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">keyLen</td>
<td class="left">Length of key in bits to use</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">keyingOption</td>
<td class="left">The TDES keying option to use</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">ivLen</td>
<td class="left">Length of IV in bits to use</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">payloadLen</td>
<td class="left">Length of plaintext or ciphertext in bits to use</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">aadLen</td>
<td class="left">Length of AAD in bits to use</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">tagLen</td>
<td class="left">Length of AEAD tag in bits to use</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">testType</td>
<td class="left">The test category type (AFT, MCT or counter). See <a href="#testtypes" class="xref">Section 3</a> for more information about what these tests do, and how to implement them.  </td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">tests</td>
<td class="left">Array of individual test case JSON objects, which are defined in <a href="#tcjs" class="xref">Section 5.2</a> </td>
<td class="left">array of testCase objects</td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.1.p.2">Some properties MUST appear in the prompt file from the server for every testGroup object. They are as follows: </p>
<p></p>

<ul>
<li>tgId</li>
<li>direction</li>
<li>payloadLen</li>
<li>testType</li>
<li>tests</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.p.4">The other properties MAY appear depending on the algorithm selected for the test vector set. The following grid defines the REQUIRED properties for each standard block cipher, as well as the valid values a server MAY use: </p>
<div id="rfc.table.9"></div>
<div id="property_grid_prompt"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Prompt Test Group Block Cipher Applicability Grid</caption>
<thead><tr>
<th class="left">algorithm</th>
<th class="left">keyLen</th>
<th class="left">keyingOption</th>
</tr></thead>
<tbody>
<tr>
<td class="left">AES-ECB</td>
<td class="left">128, 192, 256</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-CBC</td>
<td class="left">128, 192, 256</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-OFB</td>
<td class="left">128, 192, 256</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-CFB1</td>
<td class="left">128, 192, 256</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-CFB8</td>
<td class="left">128, 192, 256</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-CFB128</td>
<td class="left">128, 192, 256</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">TDES-ECB</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-CBC</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-CBCI</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-CFB1</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-CFB8</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-CFB64</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-CFBP1</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-CFBP8</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-CFBP64</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-OFB</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
<tr>
<td class="left">TDES-OFBI</td>
<td class="left"></td>
<td class="left">1, 2</td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.1.p.5">The following grid defines when each property is REQUIRED from a server for each authenticated block cipher: </p>
<div id="rfc.table.10"></div>
<div id="property_grid_prompt_auth"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Prompt Test Group Authenticated Block Cipher Applicability Grid</caption>
<thead><tr>
<th class="left">algorithm</th>
<th class="left">keyLen</th>
<th class="left">ivGen</th>
<th class="left">ivGenMode</th>
<th class="left">saltGen</th>
<th class="left">ivLen</th>
<th class="left">payloadLen</th>
<th class="left">aadLen</th>
<th class="left">tagLen</th>
<th class="left">saltLen</th>
</tr></thead>
<tbody>
<tr>
<td class="left">AES-GCM</td>
<td class="left">128, 192, 256</td>
<td class="left">"internal", "external"</td>
<td class="left">"8.2.1", "8.2.2"</td>
<td class="left"></td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-GCM-SIV</td>
<td class="left">128, 256</td>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
<td class="left">96</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left">128</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-XPN</td>
<td class="left">128, 192, 256</td>
<td class="left">"internal", "external"</td>
<td class="left">"8.2.1", "8.2.2"</td>
<td class="left">"internal", "external"</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
</tr>
<tr>
<td class="left">AES-CCM</td>
<td class="left">128, 192, 256</td>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left">within domain</td>
<td class="left"></td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.1.p.6">Note: The particular values of a domain are REQUIRED to be an integer element of the domain present in the registration used. The ACVP server MAY select predetermined or random values with particular features (ex. on a block boundary, or not on a block boundary) within the domain the client provided in the registration.  </p>
<p id="rfc.section.5.1.p.7">The following grid defines when each property is REQUIRED from a server for a key-wrap block cipher: </p>
<div id="rfc.table.11"></div>
<div id="property_grid_prompt_kw"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Prompt Test Group Key-Wrap Block Cipher Applicability Grid</caption>
<thead><tr>
<th class="left">algorithm</th>
<th class="left">keyLen</th>
<th class="left">kwCipher</th>
<th class="left">payloadLen</th>
</tr></thead>
<tbody>
<tr>
<td class="left">AES-KW</td>
<td class="left">128, 192, 256</td>
<td class="left">"cipher", "inverse"</td>
<td class="left">within domain</td>
</tr>
<tr>
<td class="left">AES-KWP</td>
<td class="left">128, 192, 256</td>
<td class="left">"cipher", "inverse"</td>
<td class="left">within domain</td>
</tr>
<tr>
<td class="left">TDES-KW</td>
<td class="left"></td>
<td class="left">"cipher", "inverse"</td>
<td class="left">within domain</td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.1.p.8">Note: The particular values of a domain are REQUIRED to be an integer element of the domain present in the registration used. The ACVP server MAY select predetermined or random values with particular features (ex. on a block boundary, or not on a block boundary) within the domain the client provided in the registration.  </p>
<p id="rfc.section.5.1.p.9">The following grid defines when each property is REQUIRED from a server for the miscellaneous block ciphers:</p>
<div id="rfc.table.12"></div>
<div id="property_grid_prompt_misc"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Prompt Test Group Miscellaneous Block Cipher Applicability Grid</caption>
<thead><tr>
<th class="left">algorithm</th>
<th class="left">keyLen</th>
<th class="left">keyingOption</th>
<th class="left">incremental</th>
<th class="left">overflow</th>
<th class="left">tweakMode</th>
<th class="left">payloadLen</th>
</tr></thead>
<tbody>
<tr>
<td class="left">AES-CTR</td>
<td class="left">128, 192, 256</td>
<td class="left"></td>
<td class="left">true, false</td>
<td class="left">true, false</td>
<td class="left"></td>
<td class="left"></td>
</tr>
<tr>
<td class="left">AES-XTS</td>
<td class="left">128, 256</td>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
<td class="left">"hex", "number"</td>
<td class="left">within domain</td>
</tr>
<tr>
<td class="left">TDES-CTR</td>
<td class="left"></td>
<td class="left">1, 2</td>
<td class="left">true, false</td>
<td class="left">true, false</td>
<td class="left"></td>
<td class="left"></td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.1.p.10">Note: The particular values of a domain are REQUIRED to be an integer element of the domain present in the registration used. The ACVP server MAY select predetermined or random values with particular features (ex. on a block boundary, or not on a block boundary) within the domain the client provided in the registration.  </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#tcjs" id="tcjs">Test Cases</a>
</h1>
<p id="rfc.section.5.2.p.1">Each test group SHALL contain an array of one or more test cases.  Each test case is a JSON object that represents a single case to be processed by the ACVP client.  The following table describes the JSON elements for each test case.  </p>
<div id="rfc.table.13"></div>
<div id="vs_tc_table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Test Case JSON Object</caption>
<thead><tr>
<th class="left">JSON Value</th>
<th class="left">Description</th>
<th class="left">JSON type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">tcId</td>
<td class="left">Numeric identifier for the test case, unique across the entire vector set.</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">key</td>
<td class="left">Encryption key to use for AES</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">key1, key2, key3</td>
<td class="left">Encryption keys to use for TDES</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">iv</td>
<td class="left">IV to use</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">tweakValue</td>
<td class="left">tweakValue used to form an IV for AES-XTS</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">salt</td>
<td class="left">The salt to use in AES-XPN (required for AES-XPN only)</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">pt</td>
<td class="left">Plaintext to use</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">ct</td>
<td class="left">Ciphertext to use</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">payloadLen</td>
<td class="left">Plaintext or Ciphertext length to use in bits. Only the most significant 'payloadLen' bits will be used.</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">aad</td>
<td class="left">AAD to use for AEAD algorithms</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">tag</td>
<td class="left">Tag to use for AEAD algorithms</td>
<td class="left">string (hex)</td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.2.p.2">Note: The applicability of each test case property is dependent on the test group and test vector (algorithm) properties. Each test type within the test group requires specific operations to be performed and thus specific data returned to the server. Consult <a href="#testtypes" class="xref">Section 3</a> for more information.  The tcId property MUST appear within every test case sent to and from the server.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#vector_responses" id="vector_responses">Test Vector Responses</a>
</h1>
<p id="rfc.section.6.p.1">After the ACVP client downloads and processes a vector set, it SHALL send the response vectors back to the ACVP server within the alloted timeframe. The following table describes the JSON object that represents a vector set response.  </p>
<div id="rfc.table.14"></div>
<div id="vr_top_table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Vector Set Response JSON Object</caption>
<thead><tr>
<th class="left">JSON Value</th>
<th class="left">Description</th>
<th class="left">JSON type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">acvVersion</td>
<td class="left">Protocol version identifier</td>
<td class="left">string</td>
</tr>
<tr>
<td class="left">vsId</td>
<td class="left">Unique numeric identifier for the vector set</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">testGroups</td>
<td class="left">Array of JSON objects that represent each test vector group. See <a href="#vr_group_table" class="xref">Table 15</a> </td>
<td class="left">array of testGroup objects</td>
</tr>
</tbody>
</table>
<p id="rfc.section.6.p.2">The testGroup Response section is used to organize the ACVP client response in a similar manner to how it receives vectors.  Several algorithms SHALL require the client to send back group level properties in its response.  This structure helps accommodate that.  </p>
<div id="rfc.table.15"></div>
<div id="vr_group_table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Vector Set Group Response JSON Object</caption>
<thead><tr>
<th class="left">JSON Value</th>
<th class="left">Description</th>
<th class="left">JSON type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">tgId</td>
<td class="left">The test group identifier</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">tests</td>
<td class="left">The tests associated to the group specified in tgId</td>
<td class="left">array of testCase objects</td>
</tr>
</tbody>
</table>
<p id="rfc.section.6.p.3">Each test case is a JSON object that represents a single test object to be processed by the ACVP client.  The following table describes the JSON elements for each test case object.  </p>
<div id="rfc.table.16"></div>
<div id="vs_tr_table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Test Case Results JSON Object</caption>
<thead><tr>
<th class="left">JSON Value</th>
<th class="left">Description</th>
<th class="left">JSON type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">tcId</td>
<td class="left">Numeric identifier for the test case, unique across the entire vector set.</td>
<td class="left">integer</td>
</tr>
<tr>
<td class="left">pt</td>
<td class="left">The IUT's pt response to a decrypt test</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">ct</td>
<td class="left">The IUT's ct response to an encrypt test</td>
<td class="left">string (hex)</td>
</tr>
<tr>
<td class="left">testPassed</td>
<td class="left">Some test cases included with decrypt operations in AES-GCM, AES-CCM, AES-XPN, AES-KW, AES-KWP, and TDES-KW will have expected failures.  </td>
<td class="left">boolean</td>
</tr>
<tr>
<td class="left">resultsArray</td>
<td class="left">Array of JSON objects that represent each iteration of a Monte Carlo Test. Each iteration will contain the key(s), pt, ct and iv</td>
<td class="left">array of objects containing pt, ct and iv (except for ECB mode)</td>
</tr>
</tbody>
</table>
<p id="rfc.section.6.p.4">Note: The tcId MUST be included in every test case object sent between the client and the server.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">The authors thank John Foley for putting together an early draft of this specification.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This memo include requests to IANA to join draft-vassilev-acvp-iana-00.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">Security considerations are addressed by the <a href="#ACVP" class="xref">ACVP Specification</a>.</p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ACVP">[ACVP]</b></td>
<td class="top">
<a title="Cisco">Barry Fussell, BF.</a>, "<a>draft-fussell-acvp-spec-00</a>", 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="AES-GCM-SIV">[AES-GCM-SIV]</b></td>
<td class="top">
<a>University of Haifa and Amazon Web Services</a>, <a>Google LLC</a> and <a>Bar Ilan University</a>, "<a>AES-GCM-SIV: Nonce Misuse-Resistant Authenticated Encryption</a>", 2018.</td>
</tr>
<tr>
<td class="reference"><b id="AES-XTS">[AES-XTS]</b></td>
<td class="top">
<a>Institute of Electrical and Electronics Engineers, Inc.</a>, "<a>The XTS-AES Tweakable Block Cipher</a>", 2008.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS-197">[FIPS-197]</b></td>
<td class="top">
<a>NIST</a>, "<a>Specification for the Advanced Encryption Standard (AES)</a>", 2001.</td>
</tr>
<tr>
<td class="reference"><b id="SP800-38A">[SP800-38A]</b></td>
<td class="top">
<a title="NIST">Morris Dworkin, MD.</a>, "<a>Recommendation for Block Cipher Modes of Operation: Methods and Techniques</a>", 2001.</td>
</tr>
<tr>
<td class="reference"><b id="SP800-38C">[SP800-38C]</b></td>
<td class="top">
<a title="NIST">Morris Dworkin, MD.</a>, "<a>Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality</a>", 2004.</td>
</tr>
<tr>
<td class="reference"><b id="SP800-38D">[SP800-38D]</b></td>
<td class="top">
<a title="NIST">Morris Dworkin, MD.</a>, "<a>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</a>", 2007.</td>
</tr>
<tr>
<td class="reference"><b id="SP800-38E">[SP800-38E]</b></td>
<td class="top">
<a title="NIST">Morris Dworkin, MD.</a>, "<a>Recommendation for Block Cipher Modes of Operation: The XTS-AES Mode for Confidentiality on Storage Devices</a>", 2010.</td>
</tr>
<tr>
<td class="reference"><b id="SP800-38F">[SP800-38F]</b></td>
<td class="top">
<a title="NIST">Morris Dworkin, MD.</a>, "<a>Recommendataion for Block Cipher Modes of Operation: Methods for Key Wrapping</a>", December 2012.</td>
</tr>
<tr>
<td class="reference"><b id="SP800-67r2">[SP800-67r2]</b></td>
<td class="top">
<a title="NIST">Elaine Barker, EB.</a>, "<a>Recommendation for the Triple Data Encryption Algorithm (TDEA) Block Cipher</a>", 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#app-reg-ex" id="app-reg-ex">Example Capabilities JSON Object</a>
</h1>
<p id="rfc.section.A.p.1">The following is a example JSON object advertising support for all block ciphers.</p>
<pre>
POST [
[{
    "acvVersion": &lt;acvp-version&gt;
},{
        "algorithm": "ACVP-AES-GCM",
        "revision": "1.0",
        "prereqVals" : 
            [{
                "algorithm" : "ACVP-AES-ECB",
                "valValue" : "123456"
            },
            {
                "algorithm" : "DRBG", 
                "valValue" : "123456"
            }],
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "ivGen": "internal",
        "ivGenMode": "8.2.2",
        "keyLen": [
            128,
            192,
            256
        ],
        "tagLen": [
            96,
            128
        ],
        "ivLen": [
            96
        ],
        "payloadLen": [
            0,
            256
        ],
        "aadLen": [
            128,
            256
        ]
    },
    {
        "algorithm": "ACVP-AES-ECB",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            192,
            256
        ]
    },
    {
        "algorithm": "ACVP-AES-CBC",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            192,
            256
        ]
    },
    {
        "algorithm": "ACVP-AES-CFB8",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            192,
            256
        ],
        "payloadLen": [
            256
        ]
    },
    {
        "algorithm": "ACVP-AES-CFB128",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            192,
            256
        ]
    },
    {
        "algorithm": "ACVP-AES-OFB",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            192,
            256
        ]
    },
    {
        "algorithm": "ACVP-AES-XPN",
        "revision": "1.0",
        "prereqVals" : 
        [{
            "algorithm" : "ACVP-AES-ECB", 
            "valValue" : "123456"
        },
        {
            "algorithm" : "DRBG", 
            "valValue" : "123456"
        }],
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "ivGen": "internal",
        "ivGenMode": "8.2.2",
        "saltGen": "internal",      
        "keyLen": [
            128,
            192,
            256
        ],
        "tagLen": [
            96,
            128
        ],
        "payloadLen": [
            0,
            128
        ],
        "aadLen": [
            120,
            128
        ]
    },
    {
        "algorithm": "ACVP-AES-CTR",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            192,
            256
        ],
        "payloadLen": [
            128
        ]
        },
        {
        "algorithm": "ACVP-AES-CCM",
        "revision": "1.0",
        "prereqVals": [
            {
                "algorithm": "ACVP-AES-ECB",
                "valValue": "same"
            }
        ],
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            192,
            256
        ],
        "tagLen": [
            128
        ],
        "ivLen": [
            56
        ],
        "payloadLen": [
            0,
            256
        ],
        "aadLen": [
            0,
            65536
        ]
    },
    {
        "algorithm": "ACVP-AES-CFB1",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            192,
            256
        ]
    },
    {
        "algorithm": "ACVP-AES-KW",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "kwCipher": [
            "cipher"
        ],
        "keyLen": [
            128,
            192,
            256
        ],
        "payloadLen": [
            512,
            192,
            128
        ]
    },
    {
        "algorithm": "ACVP-AES-KWP",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "kwCipher": [
            "cipher"
        ],
        "keyLen": [
            128,
            192,
            256
        ],
        "payloadLen": [
            8,
            32,
            96,
            808
        ]
    },
    {
        "algorithm": "ACVP-AES-XTS",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyLen": [
            128,
            256
        ],
        "payloadLen": [
            65536
        ],
        "tweakMode": [
            "hex",
            "number"
        ]
    },
    {
        "algorithm": "ACVP-TDES-ECB",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CBC",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CBCI",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-OFB",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-OFBI",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CFB64",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CFB8",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CFB1",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CFBP64",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CFBP8",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CFBP1",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ]
    },
    {
        "algorithm": "ACVP-TDES-CTR",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "keyingOption": [
            1
        ],
        "keyLen": [
            192
        ],
        "payloadLen": [
            64
        ]
    },
    {
        "algorithm": "ACVP-TDES-KW",
        "revision": "1.0",
        "direction": [
            "encrypt",
            "decrypt"
        ],
        "kwCipher": [
            "cipher"
        ],
        "payloadLen": [
            512,
            192,
            128
        ]
    }
 ]]
                            </pre>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#app-vs-ex" id="app-vs-ex">Example Vector Set Request/Responses JSON Object</a>
</h1>
<p id="rfc.section.B.p.1">The following sections provide examples of the JSON objects for each of the AES algorithms. Examples will relfect what testTypes are supported by each algorithm, ie AFT, MCT or counter.  MCT examples have only 2 iterations shown for brevity.</p>
<p id="rfc.section.B.p.2">The following shows AES-GCM AFT request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2055,
	"algorithm": "ACVP-AES-GCM",
    "revision": "1.0",
	"testGroups": [{
            tgId": 1,
            "testType": "AFT",
            "direction": "encrypt",
            "keyLen": 128,
            "ivLen": 96,
            "ivGen": "external",
            "ivGenMode": "8.2.2",
            "payloadLen": 0,
            "aadLen": 0,
            "tagLen": 32,
            "tests": [
                {
                    "tcId": 1,
                    "plainText": "",
                    "key": "10B8D4C9658590A...",
                    "aad": "",
                    "iv": "3D026F3D590BF1A7..."
                },
                {
                    "tcId": 2,
                    "plainText": "",
                    "key": "934865822A3ECCB...",
                    "aad": "",
                    "iv": "273F3B30341C779E..."
                }
			]
		},
		{
            "tgId": 19,
            "testType": "AFT",
            "direction": "decrypt",
            "keyLen": 128,
            "ivLen": 96,
            "ivGen": "external",
            "ivGenMode": "8.2.2",
            "payloadLen": 0,
            "aadLen": 120,
            "tagLen": 32,
            "tests": [
                {
                    "tcId": 271,
                    "key": "88AB5441AE2...",
                    "aad": "4E956EF528D...",
                    "iv": "810628011BB0...",
                    "cipherText": "",
                    "tag": "1180FD89"
                },
                {
                    "tcId": 272,
                    "key": "9149BE47FAEB...",
                    "aad": "938A8FA71324...",
                    "iv": "FF6B72FF25B55...",
                    "cipherText": "",
                    "tag": "6C7528F0"
                }
			]
		}
	]
}]
                       </pre>
<p id="rfc.section.B.p.3">The following shows AES-GCM AFT responses.</p>
<pre>
 
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2055,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"iv": "01020304F966B8...",
					"ct": "",
					"tag": "427F668E58F56..."
				},
				{
					"tcId": 2,
					"iv": "01020304C2855...",
					"ct": "",
					"tag": "D95BD66F7789..."
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 902,
					"pt": "763BF..."
				},
				{
					"tcId": 903,
					"testPassed": false
				}
			]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.4">The following shows AES-CCM AFT request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2061,
	"algorithm": "ACVP-AES-CCM",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"direction": "encrypt",
		"testType": "AFT",
		"ivLen": 56,
		"payloadLen": 256,
		"aadLen": 0,
		"tagLen": 128,
		"keyLen": 128,
		"tests": [{
			"tcId": 1,
			"pt": "361445511E0BD3E94E3...",
			"key": "7DB9E755181E4160C6...",
			"iv": "1C53ECD62BBED5",
			"aad": ""
		}, {
			"tcId": 2,
			"pt": "735CE37215A91074DBF...",
			"key": "7DB9E755181E4160C6...",
			"iv": "1C53ECD62BBED5",
			"aad": ""
		}]
	}, {
		"tgId": 2,
		"direction": "decrypt",
		"testType": "AFT",
		"ivLen": 56,
		"payloadLen": 0,
		"aadLen": 0,
		"tagLen": 128,
		"keyLen": 128,
		"tests": [{
			"tcId": 181,
			"ct": "533427D475EBAC3FE5...",
			"key": "A8B7C7A69E5AB940B...",
			"iv": "1BD5816AF5BB9F",
			"aad": ""
		}, {
			"tcId": 182,
			"ct": "6B774BB2D20A8A23A1...",
			"key": "A8B7C7A69E5AB940B...",
			"iv": "8140308B19BCE8",
			"aad": ""
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.5">The following shows AES-CCM AFT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
    "vsId": 2061,
    "testGroups": [{
            "tgId": 1,
            "tests": [{
                    "tcId": 1,
                    "ct": "C8AB4A739E1..."
                },
                {
                    "tcId": 2,
                    "ct": "8DE3EC5095B..."
                }
            ]
        },
        {
            "tgId": 2,
            "tests": [{
                    "tcId": 181,
                    "testPassed": false
                },
                {
                    "tcId": 182,
                    "pt": ""
                }
            ]
        }
    ]
}]
                            </pre>
<p id="rfc.section.B.p.6">The following shows AES-CBC AFT and MCT request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2057,
	"algorithm": "ACVP-AES-CBC",
    "revision": "1.0",
	"testGroups": [{
			"tgId": 1,
			"direction": "encrypt",
			"testType": "AFT",
			"keyLen": 128,
			"tests": [{
				"tcId": 1,
				"iv": "00C8F42C5B5...",
				"key": "7F9863BCD5...",
				"pt": "97549D671FA..."
			}, {
				"tcId": 2,
				"iv": "CE6747E918F...",
				"key": "25F73DBAF4...",
				"pt": "D3A0AA732D7..."
			}]
		}, {
			"tgId": 2,
			"direction": "decrypt",
			"testType": "AFT",
			"keyLen": 128,
			"tests": [{
				"tcId": 31,
				"iv": "D498F4F8462...",
				"key": "77D563ACE1...",
				"ct": "78256FA155F..."
			}, {
				"tcId": 32,
				"iv": "AB99A939B688...",
				"key": "0569B0C6DB3...",
				"ct": "EEBF23A65E83..."
			}]
		},
		{
			"tgId": 3,
			"direction": "encrypt",
			"testType": "MCT",
			"keyLen": 256,
			"tests": [{
				"tcId": 63,
				"iv": "057FB7EEDE1EBF40...",
				"key": "E5E2E9F088E2C06...",
				"pt": "6DA46A0AADB59615..."
			}]
		}, {
			"tgId": 4,
			"direction": "decrypt",
			"testType": "MCT",
			"keyLen": 128,
			"tests": [{
				"tcId": 64,
				"iv": "FD5EDEC164E504D6...",
				"key": "F7439EAC671FC4B...",
				"ct": "37ECE2FF3F391D8C..."
			}]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.7">The following shows AES-CBC AFT and MCT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2057,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "DD95E867DFCFCC..."
				},
				{
					"tcId": 2,
					"ct": "540954F0016D40..."
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 31,
					"pt": "F7251EA3C68FE..."
				},
				{
					"tcId": 32,
					"pt": "CEC14A7B465A3..."
				}
			]
		},
		{
			"tgId": 3,
			"tests": [{
				"tcId": 63,
				"resultsArray": [{
						"key": "E5E2...",
						"iv": "057FB...",
						"pt": "6DA46...",
						"ct": "3E794..."
					},
					{
						"key": "DE31...",
						"iv": "3E794...",
						"pt": "3BD32...",
						"ct": "9236D..."
					}
				]
			}]
		},
		{
			"tgId": 1,
			"tests": [{
				"tcId": 64,
				"resultsArray": [{
						"key": "F743...",
						"iv": "FD5ED...",
						"ct": "37ECE...",
						"pt": "52FC3..."
					},
					{
						"key": "A5BF...",
						"iv": "52FC3...",
						"ct": "4400F...",
						"pt": "66204..."
					}
				]
			}]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.8">The following shows AES-ECB AFT and MCT request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2056,
	"algorithm": "ACVP-AES-ECB",
    "revision": "1.0",
	"testGroups": [{
			"tgId": 1,
            "testType": "AFT",
            "direction": "encrypt",
            "keylen": 128,
            "tests": [
                {
                    "tcId": 1,
                    "plainText": "F34481E...",
                    "key": "0000000000000..."
                },
                {
                    "tcId": 2,
                    "plainText": "9798C46...",
                    "key": "0000000000000..."
                }
			]
		},
		{
            "tgId": 25,
            "testType": "AFT",
            "direction": "encrypt",
            "keylen": 128,
            "tests": [
                {
                    "tcId": 2079,
                    "plainText": "1C46FA6...",
                    "key": "18D3248D32630..."
                },
                {
                    "tcId": 2080,
                    "plainText": "5AC1B2D...",
                    "key": "26007B74016FA..."
                }
			]
		},
        {
        "tgId": 31,
        "testType": "MCT",
        "direction": "encrypt",
        "keylen": 128,
        "tests": [
                {
                    "tcId": 2139,
                    "key": "9489F6FFA4A74...",
			        "pt": "2D984D2F1FC178..."
                }
            ]
        },
        {
        "tgId": 34,
        "testType": "MCT",
        "direction": "decrypt",
        "keylen": 128,
        "tests": [
                {
                    "tcId": 2142
                    "key": "9489F6FFA4A74...",
			        "ct": "2D984D2F1FC178..."
                }
            ]
        }
	]
}]
                            </pre>
<p id="rfc.section.B.p.9">The following shows AES-ECB AFT and MCT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2056,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "43FB8A36F168E3..."
				},
				{
					"tcId": 2,
					"ct": "27549D65BE8056..."
				}
			]
		},
		{
			"tgId": 1,
			"tests": [{
					"tcId": 31,
					"pt": "F7F42B062BD643..."
				},
				{
					"tcId": 32,
					"pt": "EAF9AAA67B6C0E..."
				}
			]
		},
		{
			"tgId": 3,
			"tests": [{
				"tcId": 61,
				"resultsArray": [{
						"key": "A4A8255E7...",
						"pt": "B3B8F494D0...",
						"ct": "619D5B0921..."
					},
					{
						"key": "C5357E575...",
						"pt": "619D5B0921...",
						"ct": "28CF1C5DD2..."
					}
				]
			}]
		},
		{
			"tgId": 4,
			"tests": [{
				"tcId": 64,
				"resultsArray": [{
						"key": "4D3BE577E...",
						"ct": "0FE92E22BA...",
						"pt": "73ED187BFE..."
					},
					{
						"key": "3ED6FD0C1...",
						"ct": "73ED187BFE...",
						"pt": "59550A36E1..."
					}
				]
			}]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.10">The following shows AES-OFB AFT and MCT request vectors.</p>
<pre>
[{
    "acvVersion": &lt;acvp-version&gt;,
},{
	"vsId": 2060,
	"algorithm": "ACVP-AES-OFB",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"direction": "encrypt",
		"testType": "AFT",
		"keyLen": 128,
		"tests": [{
			"tcId": 1,
			"iv": "0F24B3F7808F292BC39128...",
			"key": "8ECE26B1880C4B1F0A59E...",
			"pt": "A8EF19C7182527C8CBBEE1..."
		}, {
			"tcId": 2,
			"iv": "1D1CC64F9F004192B6BE35...",
			"key": "054240C952C99D5B6E387224F...,
			"pt": "EBFA3F5F990B678AA884FB..."
		}]
	}, {
		"tgId": 2,
		"direction": "decrypt",
		"testType": "AFT",
		"keyLen": 128,
		"tests": [{
			"tcId": 31,
			"iv": "A5F67A6CB0238A5DFB166...",
			"key": "A3988AC61E9FB4820876...",
			"ct": "CF6F24E68CEC8B97CB88D..."
		}, {
			"tcId": 32,
			"iv": "4098786D4EF05639B5A20...",
			"key": "5D22EAF883FB2B1847BF...",
			"ct": "7203926F1210401F566E0..."
		}]
	}, {
		"tgId": 3,
		"direction": "encrypt",
		"testType": "MCT",
		"keyLen": 128,
		"tests": [{
			"tcId": 61,
			"iv": "39F33D19A09AAFD200D4C...",
			"key": "190316BF21DE21E96FCF...",
			"pt": "E4D7F490829710CADFD67..."
		}]
	}, {
		"tgId": 4,
		"direction": "decrypt",
		"testType": "MCT",
		"keyLen": 128,
		"tests": [{
			"tcId": 64,
			"iv": "1915C8A7AFEBB26AAE97C...",
			"key": "9489F6FFA4A7480D5B34...",
			"ct": "2D984D2F1FC178CAB247F..."
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.11">The following shows AES-OFB AFT and MCT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2060,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "B5D16C4219AC38..."
				},
				{
					"tcId": 2,
					"ct": "B85AF8646842A9..."
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 31,
					"pt": "0863AB3A0CA17C..."
				},
				{
					"tcId": 32,
					"pt": "BF69D1BE04D013..."
				}
			]
		},
		{
			"tgId": 3,
			"tests": [{
				"tcId": 61,
				"resultsArray": [{
						"key": "190316BF...",
						"iv": "39F33D19A...",
						"pt": "E4D7F4908...",
						"ct": "F55626877..."
					},
					{
						"key": "EC553038...",
						"iv": "F55626877...",
						"pt": "A04BCACFF...",
						"ct": "1EAA7DE30..."
					}
				]
			}]
		},
		{
			"tgId": 4,
			"tests": [{
				"tcId": 64,
				"resultsArray": [{
						"key": "9489F6FF...",
						"iv": "1915C8A7A...",
						"ct": "2D984D2F1...",
						"pt": "0FE5765E5..."
					},
					{
						"key": "9B6C80A1...",
						"iv": "0FE5765E5...",
						"ct": "F29F68E2E...",
						"pt": "39AC0B63E..."
					}
				]
			}]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.12">The following shows AES-CFB1 AFT and MCT request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2062,
	"algorithm": "ACVP-AES-CFB1",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"direction": "encrypt",
		"testType": "AFT",
		"keyLen": 128,
		"tests": [{
			"tcId": 67,
			"iv": "F34481EC3CC627BACD5DC3...",
			"key": "000000000000000000000...",
			"pt": "00",
			"payloadLen": 1
		}, {
			"tcId": 68,
			"iv": "9798C4640BAD75C7C3227D...",
			"key": "000000000000000000000...",
			"pt": "00",
			"payloadLen": 1
		}]
	}, {
		"tgId": 2,
		"direction": "decrypt",
		"testType": "AFT",
		"keyLen": 128,
		"tests": [{
			"tcId": 31,
			"iv": "C74388BA333118CDBDF578...",
			"key": "8DE5E0586C4EA40FC36C0...",
			"ct": "80",
			"payloadLen": 1
		}, {
			"tcId": 32,
			"iv": "0B1B558F3AF46F2E6AB29D...",
			"key": "E52350E8E8EE950A3C2E3...",
			"ct": "80",
			"payloadLen": 1
		}]
	}, {
		"tgId": 3,
		"direction": "encrypt",
		"testType": "MCT",
		"keyLen": 128,
		"tests": [{
			"tcId": 61,
			"iv": "D4A4A028EEA3BCA708A31E...",
			"key": "A3B254EAB3B0C8C60EF6A...",
			"pt": "80",
			"payloadLen": 1
		}]
	}, {
		"tgId": 4,
		"direction": "decrypt",
		"testType": "MCT",
		"keyLen": 128,
		"tests": [{
			"tcId": 64,
			"iv": "75BEE06DEC8A99EC0C7E7F...",
			"key": "7C87174CB990272D0F2F2...",
			"ct": "00",
			"payloadLen": 1
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.13">The following shows AES-CFB1 AFT and MCT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2062,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 67,
					"ct": "00"
				},
				{
					"tcId": 68,
					"ct": "80"
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 31,
					"pt": "00"
				},
				{
					"tcId": 32,
					"pt": "80"
				}
			]
		},
		{
			"tgId": 3,
			"tests": [{
				"tcId": 61
				"resultsArray": [{
						"key": "A3B254EAB...",
						"iv": "D4A4A028EE...",
						"pt": "80",
						"ct": "00"
					},
					{
						"key": "8FFC23126...",
						"iv": "2C4E77F8D0...",
						"pt": "00",
						"ct": "00"
					}
				]
			}]
		}, {
			"tgId": 4,
			"tests": [{
				"tcId": 64
				"resultsArray": [{
						"key": "7C87174CB...",
						"iv": "75BEE06DEC...",
						"ct": "00",
						"pt": "00"
					},
					{
						"key": "4B2492A3F...",
						"iv": "37A385EF42...",
						"ct": "80",
						"pt": "80"
					}
				]
			}]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.14">The following shows AES-CFB8 AFT and MCT request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2058,
	"algorithm": "ACVP-AES-CFB8",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"direction": "encrypt",
		"testType": "AFT",
		"keyLen": 128,
		"tests": [{
			"tcId": 1,
			"iv": "4EBD4CE189E6DA65026C2A...",
			"key": "5FA02465F28B76C441C7B...",
			"pt": "AF5E"
		}, {
			"tcId": 2,
			"iv": "9A8017353E953B5AEC4D78...",
			"key": "538EB5E1CBFEA61CC6B3D...",
			"pt": "6ED3759B"
		}]
	}, {
		"tgId": 2,
		"direction": "decrypt",
		"testType": "AFT",
		"keyLen": 128,
		"tests": [{
			"tcId": 31,
			"iv": "1808A0F308838AA6F9F703...",
			"key": "DB7FFD9166E4A5BACB022...",
			"ct": "41DA"
		}, {
			"tcId": 32,
			"iv": "4D75785D44B1B247788186...",
			"key": "7201F5CC867A8DCE044DB...",
			"ct": "E267BC1B"
		}]
	}, {
		"tgId": 3,
		"direction": "encrypt",
		"testType": "MCT",
		"keyLen": 128,
		"tests": [{
			"tcId": 61,
			"iv": "4B8F7DCCAD48776C746B79...",
			"key": "FD0B5848870C7431179EB...",
			"pt": "AD"
		}]
	}, {
		"tgId": 4,
		"direction": "decrypt",
		"testType": "MCT",
		"keyLen": 128,
		"tests": [{
			"tcId": 64,
			"iv": "5D2080050855970CE15DC1...",
			"key": "EA378F16FF6144EF58E67...",
			"ct": "83"
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.15">The following shows AES-CFB8 AFT and MCT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2058,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "181B"
				},
				{
					"tcId": 2,
					"ct": "DFF540F0"
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 31,
					"pt": "DA19"
				},
				{
					"tcId": 32,
					"pt": "B2133D11"
				}
			]
		},
		{
			"tgId": 3,
			"tests": [{
				"tcId": 61,
				"resultsArray": [{
						"key": "FD0B58488...",
						"iv": "4B8F7DCCAD...",
						"pt": "AD",
						"ct": "3A"
					},
					{
						"key": "6B96D9FD0...",
						"iv": "969D81B585...",
						"pt": "2F",
						"ct": "BD"
					}
				]
			}]
		},
		{
			"tgId": 4,
			"tests": [{
				"tcId": 64,
				"resultsArray": [{
						"key": "EA378F16F...",
						"iv": "5D20800508...",
						"ct": "83",
						"pt": "E6"
					},
					{
						"key": "31A0B0001A...",
						"iv": "DB973F16E5D...",
						"ct": "24",
						"pt": "0A"
					}
				]
			}]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.16">The following shows AES-CFB128 AFT and MCT request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2059,
	"algorithm": "ACVP-AES-CFB128",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"direction": "encrypt",
		"testType": "AFT",
		"keyLen": 128,
		"tests": [{
			"tcId": 1,
			"iv": "24AD71C9734E64B8AC458...",
			"key": "55B2490AD74A470F5CFE...",
			"pt": "FE9C6B296C58324FE8B48..."
		}, {
			"tcId": 2,
			"iv": "C0042889D189B508C5B88...",
			"key": "AB383065E16B17306B50...",
			"pt": "19F109316F7F740BD48FF..."
		}]
	}, {
		"tgId": 2,
		"direction": "decrypt",
		"testType": "AFT",
		"keyLen": 128,
		"tests": [{
			"tcId": 31,
			"iv": "40619E2F346B02D49BCEE...",
			"key": "744F5B5D7813974E0DE2...",
			"ct": "5B12E9B418F720C344698..."
		}, {
			"tcId": 32,
			"iv": "D571797F5623F8442C2CE...",
			"key": "6559CA840CF8360A8AF7...",
			"ct": "0A17C2F7A82BBDE588262..."
		}]
	}, {
		"tgId": 3,
		"direction": "encrypt",
		"testType": "MCT",
		"keyLen": 128,
		"tests": [{
			"tcId": 61,
			"iv": "4AAF5D6F6E25B8A868D8D...",
			"key": "0D0949FB32A2DC6BA267...",
			"pt": "98EE9313512D5BEC19715..."
		}]
	}, {
		"tgId": 4,
		"direction": "decrypt",
		"testType": "MCT",
		"keyLen": 128,
		"tests": [{
			"tcId": 64,
			"iv": "663D4E1B6F09FE1935E69...",
			"key": "5924D41588E2DC657514...",
			"ct": "83C1C3AF23A3F658DF142..."
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.17">The following shows AES-CFB128 AFT and MCT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2059,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "1C9BF58FF640041F8E..."
				},
				{
					"tcId": 2,
					"ct": "2C822934B8D747336..."
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 31,
					"pt": "4BC37D318900379CD75..."
				},
				{
					"tcId": 32,
					"pt": "523057EC2E120826..."
				}
			]
		},
		{
			"tgId": 3,
			"tests": [{
				"tcId": 61,
				"resultsArray": [{
						"key": "0D0949FB32A...",
						"iv": "4AAF5D6F6E25...",
						"pt": "98EE9313512D...",
						"ct": "7E94144C4DD4..."
					},
					{
						"key": "739D5DB77F7...",
						"iv": "7E94144C4DD4...",
						"pt": "E93E4CCB2BD1...",
						"ct": "050CE71D2451..."
					}
				]
			}]
		},
		{
			"tgId": 4,
			"tests": [{
				"tcId": 64,
				"resultsArray": [{
						"key": "5924D41588E...",
						"iv": "663D4E1B6F09...",
						"ct": "83C1C3AF23A3...",
						"pt": "32D4D152D488..."
					},
					{
						"key": "6BF005475C6...",
						"iv": "32D4D152D488...",
						"ct": "3CC4191B8EBE...",
						"pt": "BB97ADEF9F08..."
					}
				]
			}]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.18">The following shows AES-CTR AFT and counter request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2066,
	"algorithm": "ACVP-AES-CTR",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"direction": "encrypt",
		"keyLen": 128,
		"testType": "AFT",
		"tests": [{
			"tcId": 1,
			"key": "E870131CE703D6514E761F95E6EE9EFB",
			"payloadLen": 128,
			"iv": "53F225D8DE97F14BFE3EC65EC3FFF7D3",
			"pt": "91074131F1F86CCD548D22A69340FF39"
		}, {
			"tcId": 2,
			"key": "2C759788A49BF060353344413A1D0FFC",
			"payloadLen": 128,
			"iv": "A4DE6D846C3AE5D5FF78163FF209AFE4",
			"pt": "BA37A61FD041F2881921D4705AD329DD"
		}]
	}, {
		"tgId": 2,
		"direction": "decrypt",
		"keyLen": 128,
		"testType": "AFT",
		"tests": [{
			"tcId": 31,
			"key": "51B4375D6FB348A55477E3C3163F59C7",
			"payloadLen": 128,
			"iv": "93893A056C6C6F866A04D657A544F1F8",
			"ct": "F2FF4B0C2E771A41525EA67AD036B459"
		}, {
			"tcId": 32,
			"key": "6A4F0B775490D554F19B5A061A362666",
			"payloadLen": 128,
			"iv": "9877D2AB7568CEF28BA945B046BA20BE",
			"ct": "09F4EEF2322BE13D75FF6DA86E8617B5"
		}]
	}, {
		"tgId": 3,
		"direction": "encrypt",
		"keyLen": 128,
		"testType": "CTR",
		"tests": [{
			"tcId": 829,
			"key": "3A9A8485E1B7BA1987F88F8C095257C4",
			"payloadLen": 12800,
			"pt": "CE8E4B6F7C68DE5FDE3..."
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.19">The following shows AES-CTR AFT and counter responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2066,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "3AF64C7037EE4813D8..."
				},
				{
					"tcId": 2,
					"ct": "2DFDFCDDC4CFD3CBCE..."
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 31,
					"pt": "349012E0807CA95CA5..."
				},
				{
					"tcId": 32,
					"pt": "2986D4B3FB208F0189..."
				}
			]
		},
		{
			"tgId": 3,
			"tests": [{
				"tcId": 829,
				"ct": "676EC652D5B095136..."
			}]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.20">The following shows AES-XPN AFT request vectors.</p>
<pre>
[{
  "acvVersion": &lt;acvp-version&gt;
},{
  "algorithm": "ACVP-AES-XPN",
  "revision": "1.0",
  "vsId": 1,
  "testGroups": [
    {
      "tgId": 1,
      "testType": "AFT",
      "direction": "encrypt",
      "keyLen": 128,
      "ivLen": 96,
      "ivGen": "external",
      "ivGenMode": "8.2.2",
      "saltLen": 96,
      "saltGen": "external",
      "payloadLen": 128,
      "aadLen": 120,
      "tagLen": 64,
      "tests": [
        {
          "tcId": 1,
          "plainText": "4849547C706231E248148...",
          "key": "4A23FDD31C1B321C1D3E1A74ECA9585A",
          "aad": "6B55B1B784180DE574F7709E480273",
          "iv": "A05134709620EAB47DE77FCB",
          "salt": "F0C77CB78D20BBDCF3A3C5EB"
        },
        {
          "tcId": 2,
          "plainText": "BF1D8173DA7F0273B7DA8...",
          "key": "254E5AFE555D807E5ECC2FFAB2E3E107",
          "aad": "304A2EC82959B419B8852F5C6A09D1",
          "iv": "1BA39F6A71F075FEB72B91D6",
          "salt": "AF44CD3E80088B8FD252AAB0"
        }
      ]
    }
  ]
}]
                            </pre>
<p id="rfc.section.B.p.21">The following shows AES-XPN AFT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
  "vsId": 1,
  "testGroups": [
    {
      "tgId": 1,
      "tests": [
        {
          "tcId": 1,
          "testPassed": false
        },
        {
          "tcId": 2,
          "cipherText": "D3104958599BE7BB9E672F...",
          "tag": "48408062AA84718B"
        }
      ]
    }
  ]
}]
                            </pre>
<p id="rfc.section.B.p.22">The following shows AES-XTS AFT request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2065,
	"algorithm": "ACVP-AES-XTS",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"testType": "AFT",
		"direction": "encrypt",
		"keyLen": 128,
		"tweakMode": "hex",
		"payloadLen": 65536,
		"tests": [{
			"tcId": 1,
			"key": "2866E3659E11C7890313EDAC9...",
			"tweakValue": "C7850E1C99DA28C5E7...",
			"pt": "03F912D53EA625A7D206002864..."
		}, {
			"tcId": 2,
			"key": "98B66C26FF9E4EF2BCBC3A212...",
			"tweakValue": "57B127C8DAD60138C5...",
			"pt": "20D7E083519F39DB185CDA2397..."
		}]
	}, {
		"tgId": 2,
		"testType": "AFT",
		"direction": "decrypt",
		"keyLen": 128,
		"tweakMode": "hex",
		"payloadLen": 65536,
		"tests": [{
			"tcId": 101,
			"key": "BB626CADBBFB907AC5C795080...",
			"tweakValue": "8B7E45A9200BDC72EB...",
			"ct": "B85B91029478C3E02EBC619EC7..."
		}, {
			"tcId": 102,
			"key": "9B859C56C1542C19F29AA7A4F...",
			"tweakValue": "99FE35549768F476E2...",
			"ct": "53CEE8379B03A38E33CCCC6EA0..."
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.23">The following shows AES-XTS AFT responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2065,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "97ED8057287E4FD0E1..."
				},
				{
					"tcId": 2,
					"ct": "BCACA25E6A625DB16..."
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 101,
					"pt": "8AD40CBE09CD92FB0..."
				},
				{
					"tcId": 102,
					"pt": "07DD39402F4D427D7..."
				}
			]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.24">The following shows AES-KW request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2063,
	"algorithm": "ACVP-AES-KW",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"testType": "AFT",
		"direction": "encrypt",
		"kwCipher": "cipher",
		"keyLen": 128,
		"payloadLen": 192,
		"tests": [{
			"tcId": 1,
			"key": "71389B09A3EA1AAE1F265CD3DE8FABB7",
			"pt": "3D90BE277A057C024A485F02486D733..."
		}, {
			"tcId": 2,
			"key": "B75DB6D92A66A3E8E991FEDBA3DAACA7",
			"pt": "3323EC2514C2902C424ABE968CA09FD..."
		}]
	}, {
		"tgId": 2,
		"testType": "AFT",
		"direction": "decrypt",
		"kwCipher": "cipher",
		"keyLen": 128,
		"payloadLen": 192,
		"tests": [{
			"tcId": 901,
			"key": "E5319E0061F89DE08CB590EA...",
			"ct": "1DE720863C759EC0682429AA4..."
		}, {
			"tcId": 902,
			"key": "D16C5C5FDE26C1962342AACF...",
			"ct": "F2EC43D61F2F356E1B2850D7C..."
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.25">The following shows AES-KW responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2063,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "BD009027DA8F4176B..."
				},
				{
					"tcId": 2,
					"ct": "B8BB3D3C76FDFD359..."
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 901,
					"pt": "A6BA646D0D33808AB..."
				},
				{
					"tcId": 902,
					"pt": "B40AC5F6ED5A706CB..."
				}
			]
		}
	]
}]
                            </pre>
<p id="rfc.section.B.p.26">The following shows AES-KWP request vectors.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2064,
	"algorithm": "ACVP-AES-KWP",
    "revision": "1.0",
	"testGroups": [{
		"tgId": 1,
		"testType": "AFT",
		"direction": "encrypt",
		"kwCipher": "cipher",
		"keyLen": 128,
		"payloadLen": 808,
		"tests": [{
			"tcId": 1,
			"key": "EE3B424525EE1B2D0B8CDC4CCB15F018",
			"pt": "269701A6DE9A2E8A8B2E28027..."
		}, {
			"tcId": 2,
			"key": "579C5EBBD1D07F828251FE567326C5DD",
			"pt": "634945E0FD1FA2E733CD60462..."
		}]
	}, {
		"tgId": 2,
		"testType": "AFT",
		"direction": "decrypt",
		"kwCipher": "cipher",
		"keyLen": 128,
		"payloadLen": 808,
		"tests": [{
			"tcId": 301,
			"key": "0EB557E0F938E08662EB9EDAAE05725F",
			"ct": "1BB87C360F2B644CD0BC75369..."
		}, {
			"tcId": 302,
			"key": "644E2869C9698ADBB4417A8ED65748DC",
			"ct": "583741B7624759F37EED76F76..."
		}]
	}]
}]
                            </pre>
<p id="rfc.section.B.p.27">The following shows AES-KWP responses.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
	"vsId": 2064,
	"testGroups": [{
			"tgId": 1,
			"tests": [{
					"tcId": 1,
					"ct": "58385237F04FD67F0..."
				},
				{
					"tcId": 2,
					"ct": "0D6FE2D0A8605981E..."
				}
			]
		},
		{
			"tgId": 2,
			"tests": [{
					"tcId": 300,
					"ct": "D2A239230130B6077..."
				},
				{
					"tcId": 301,
					"testPassed": false
				}
			]
		}
	]
}]
                            </pre>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#app-tdes1-results-ex" id="app-tdes1-results-ex">Example TDES Test and Results JSON Object</a>
</h1>
<p id="rfc.section.C.p.1">The following is a example JSON object for test vectors sent from the ACVP server to the crypto module for an TDES-ECB algorithm functional test.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
    "vsId": 1564,
    "algorithm": "ACVP-TDES-ECB",
    "revision": "1.0",
    "testGroups": [{
        "tgId": 1,
        "direction": "encrypt",
        "testType": "AFT",
        "tests": [{
            "tcId": 236,
            "key1": "5BE5B5FE9BB3E36D",
            "key2": "26E92C6DD35D7AB3",
            "key3": "4F89ADAD15D62FE3",
            "pt": "7119CCA0648787AE"
        }, {
            "tcId": 237,
            "key1": "2C7015EC2C044591",
            "key2": "230D79A1D0F2469D",
            "key3": "7A9EF7FDC4383131",
            "pt": "772923F53BA2EA60E7AE232..."
        }]
    }]
}]
                            </pre>
<p id="rfc.section.C.p.2">The following is a example JSON object for test results sent from the crypto module to the ACVP server for an TDES-ECB algorithm functional test.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
    "vsId": 1564,
    "testGroups": [{
        "tgId": 1,
        "tests": [{
                "tcId": 236,
                "ct": "1E85F8256575B8B1"
            },
            {
                "tcId": 237,
                "ct": "BEFD0E02088D48648FEBAAF..."
            }
        ]
    }]
}]
                            </pre>
<p id="rfc.section.C.p.3">The following is a example JSON object for test vectors sent from the ACVP server to the crypto module for the TDES-CFB1 algorithm functional test.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
    "vsId": 1564,
    "algorithm": "ACVP-TDES-CFB1",
    "revision": "1.0",
    "testGroups": [{
            "tgId": 1,
            "direction": "encrypt",
            "testType": "AFT",
            "keyingOption": 1,
            "tests": [{
                "tcId": 1,
                "key1": "1046913489980131",
                "key2": "1046913489980131",
                "key3": "1046913489980131",
                "pt": "00",
                "payloadLen": 1,
                "iv": "0000000000000000"
            }]
        },
        {
            "tgId": 2,
            "direction": "encrypt",
            "testType": "MCT",
            "keyingOption": 1,
            "tests": [{
                "tcId": 961,
                "key1": "337C857E01DE54B7",
                "key2": "F106296828FCCA0D",
                "key3": "2F65BF5A655FFFA3",
                "pt": "80",
                "payloadLen": 1,
                "iv": "0C4CCC40D9C8C5D7"
            }]
        }
    ]
}]
                            </pre>
<p id="rfc.section.C.p.4">The following is a example JSON object for test results sent from the crypto module to the ACVP server for an TDES-CFB1 algorithm functional test.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
    "vsId": 1564,
    "testGroups": [{
            "tgId": 1,
            "tests": [{
                "tcId": 1,
                "ct": "00"
            }]
        },
        {
            "tgId": 2,
            "tests": [{
                "tcId": 961
                "resultsArray": [{
                        "key1": "337C857E01DE54B7",
                        "key2": "F106296828FCCA0D",
                        "key3": "2F65BF5A655FFFA3",
                        "pt": "80",
                        "ct": "00",
                        "iv": "0C4CCC40D9C8C5D7"
                    },
                    {
                        "key1": "290E7326C8833420",
                        "key2": "8FE6BF67EF0B2325",
                        "key3": "3E2976E05EB0646D",
                        "pt": "80",
                        "ct": "80",
                        "iv": "1A73F758C95C6196"
                    }
                ]
            }]
        }
    ]
}]
                            </pre>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#app-tdes2-results-ex" id="app-tdes2-results-ex">Example TDES MCT Test and Results JSON Object</a>
</h1>
<p id="rfc.section.D.p.1">The following is a example JSON object for test vectors sent from the ACVP server to the crypto module for an TDES-ECB Monte Carlo test.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
    "vsId": 1564,
    "algorithm": "ACVP-TDES-ECB",
    "revision": "1.0",
    "testGroups": [{
        "tgId": 1,
        "direction": "encrypt",
        "testType": "MCT",
        "tests": [{
            "tcId": 492,
            "key1": "0EABB0E6B0F129D5",
            "key2": "DF61EAD07315DA37",
            "key3": "EFA2B6A252A18694",
            "ct": "2970B363C1461FAF"
        }]
    }]
}]
                            </pre>
<p id="rfc.section.D.p.2">The following is a example JSON object for test results sent from the crypto module to the ACVP server for an TDES-ECB Monte Carlo test, only 2 iterations shown for brevity. For MCT results of each iteration are fed into the next iteration.  Therefore the results carry all fields to assist in any failure diagnosis.</p>
<pre>
[{
	"acvVersion": &lt;acvp-version&gt;
},{
    "vsId": 1564,
    "testGroups": [{
        "tgId": 1,
        "tests": [{
            "tcId": 492,
            "resultsArray": [{
                    "key1": "0EABB0E6B0F129D5",
                    "key2": "DF61EAD07315DA37",
                    "key3": "EFA2B6A252A18694",
                    "ct": "2970B363C1461FAF",
                    "pt": "40F806F9DE3466C0"
                },
                {
                    "key1": "4F52B61F6EC4...",
                    "key2": "2FEC373726FE...",
                    "key3": "37B57029B65B...",
                    "ct": "40F806F9DE3466C0",
                    "pt": "A498B9748F2FB1E5"
                }
            ]
        }]
    }]
}]
                            </pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher Celi</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Celi</span>
	  </span>
	</span>
	<span class="org vcardline">National Institute of Standards and Technology</span>
	<span class="adr">
	  <span class="vcardline">100 Bureau Drive</span>

	  <span class="vcardline">
		<span class="locality">Gaithersburg</span>,  
		<span class="region">MD</span> 
		<span class="code">20899</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christopher.celi@nist.gov">christopher.celi@nist.gov</a></span>

  </address>
</div>

</body>
</html>
